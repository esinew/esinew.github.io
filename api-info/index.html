{"posts":[{"fileName":"bionioaio-zheng-li","abstract":"","description":"以银行取款为例： 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给O...","title":"BIO,NIO,AIO整理","tags":[],"feature":"","link":"https://esinew.github.io/post/bionioaio-zheng-li/","stats":{"text":"3 min read","time":141000,"words":664,"minutes":3},"isTop":false,"toc":"","date":"2020-07-03 23:29:27","dateFormat":"2020-07-03"},{"fileName":"http11-he-http2-de-bi-jiao","abstract":"","description":" ...","title":"http1.1和http2的比较","tags":[],"feature":"","link":"https://esinew.github.io/post/http11-he-http2-de-bi-jiao/","stats":{"text":"0 min read","time":0,"words":0,"minutes":0},"isTop":false,"toc":"","date":"2020-06-30 01:13:05","dateFormat":"2020-06-30"},{"fileName":"fei-bo-na-qi-suan-fa-ji-qi-gai-jin","abstract":"","description":"斐波那契算法 Fibonacci(int n){ if(n==1||n==2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2)； } 改进（解决溢出问题、性能问题） priva...","title":"斐波那契算法及其改进","tags":[],"feature":"https://esinew.github.io//post-images/fei-bo-na-qi-suan-fa-ji-qi-gai-jin.jpg","link":"https://esinew.github.io/post/fei-bo-na-qi-suan-fa-ji-qi-gai-jin/","stats":{"text":"4 min read","time":204000,"words":716,"minutes":4},"isTop":false,"toc":"","date":"2020-06-30 01:09:44","dateFormat":"2020-06-30"},{"fileName":"mybiatis-shi-yong-mybatiscodehelperpro-cha-jian-kuai-su-kai-fa","abstract":"","description":"（转载自 简书 葛俊_0f97） 如何达到最快的效率 下面是我的开发流程 java类生成crud 不再推荐使用 各种功能没有数据库生成crud 方便 数据库生成crud 在表字段 添加减少字段 合并代码也做得更好 数据库的话 首先要建表 ...","title":"Mybiatis使用MybatisCodeHelperPro插件快速开发","tags":[],"feature":"https://esinew.github.io//post-images/mybiatis-shi-yong-mybatiscodehelperpro-cha-jian-kuai-su-kai-fa.png","link":"https://esinew.github.io/post/mybiatis-shi-yong-mybatiscodehelperpro-cha-jian-kuai-su-kai-fa/","stats":{"text":"3 min read","time":135000,"words":638,"minutes":3},"isTop":false,"toc":"","date":"2020-06-29 02:14:31","dateFormat":"2020-06-29"},{"fileName":"mysqlinnodbsuo-yin-de-yuan-li","abstract":"","description":"(转载作者：孤独烟 出处： http://rjzheng.cnblogs.com/) 引言 回想四年前，我在学习mysql的索引这块的时候，老师在讲索引的时候，是像下面这么说的 索引就像一本书的目录。而当用户通过索引查找数据时，就好比用户...","title":"Mysql(InnoDB)索引的原理","tags":[],"feature":"https://esinew.github.io//post-images/mysqlinnodbsuo-yin-de-yuan-li.jpg","link":"https://esinew.github.io/post/mysqlinnodbsuo-yin-de-yuan-li/","stats":{"text":"6 min read","time":306000,"words":1428,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></li>\n<li><a href=\"#%E6%AD%A3%E6%96%87\">正文</a>\n<ul>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A7%91%E6%99%AE\">索引的科普</a></li>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\">索引原理介绍</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-24 10:00:13","dateFormat":"2020-06-24"},{"fileName":"mysql-shi-wu-ge-chi-ji-bie-ji-mvcc","abstract":"<p>MySQL定义了4类隔离级别，包括一些具体规则，用来限定事物内外的哪些改变时可见的，哪些改变时不可见的，低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>\n<p><strong>第一类：</strong> Read Uncommitted(读取未提交的内容)事务A/事务B    在该隔离级别，所有事物都可以看到其他未提交事务的执行结果，本隔离级别很少用于实际应用，因为他的性能页不比其他级别好多少，读取未提交的数据，也被称之为脏读（Dirty Read）。</p>\n<p><strong>第二类：</strong> Read Committed(读取提交内容)    这是大多数数据库系统的默认隔离级别（但不是mysql默认的），他满足了隔离的简单定义：一个事物在提交之前对其他事物是不可见的，这种隔离级别也支持所谓的不可重复读取（Nonerepeatable Read）,因为同一事务的其他实例在该实例处理其他期间可能会有新的commit，所以同一select可能返回不同结果。</p>\n<p><strong>第三类：</strong> Repeatable Read(可复读)    这是mysql默认的隔离级别，他确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，不过理论上，这会导致另一个棘手的问题，幻读（Phantom Read），简单的说，幻读指当用户读取某一范围的数据行时，另一个事物又在该范围内插入了新行，当用户再读取该范围内的数据时，会发现有新的&quot;幻影&quot;行，Innodb和Falcon存储引擎通过多版本并发控制（MVCC）机制解决了该问题。</p>\n<p><strong>第四类：</strong> Serializerable(可串行化)    这是最高的隔离级别，他通过强制事物排序，使之不可能相互冲突，从而解决了幻读问题，简言之，它是在每个读的数据行上加共享锁，在这个级别，可能导致大量的超时现象和锁竞争。</p>\n<p>脏读：    某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务RollBack了操作，则后面的事物所读去的数据就是不正确的。<br>\n幻读：    在一个事务的两次查询中数据不一致，例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的数据，先前的事务在接下来的查询中，就会发现有几列数据是他先前所没有的。（数据条数不同）<br>\n不可重复读：    在一个事物的两次查询中数据不一致，这可能是两次查询过程中间插入了一个事物更新的原有的数据。（同一条数据）<br>\n以上四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。<br>\n隔离级别 脏读 不可重复读 幻读读取未提交内容 v v v读取已提交内容 x v v 可重复读 x x v 可串行化 x x x<br>\n修改MySQL隔离级别：</p>\n<p><em>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</em></p>\n<p><img src=\"https://esinew.github.io//post-images/1592963778005.jpg\" alt=\"\" loading=\"lazy\"><br>\n修改完成后重启mysql，使其生效：</p>\n<p><u><em>sudo service mysql restart</em></u></p>\n<p><strong>Django提供了一个API来控制数据库事务</strong></p>\n<p><u><em>atomic(using=None, savepoint=True)</em></u></p>\n<p>原子性： 是由mysql的事物操作来界定的，atomic允许我们在执行代码块时，在数据库层面提供原子性保证，如果代码块成功完成，相应的变化会被提交到数据库进行commit，否则会进行rollback。</p>\n<p>atomic可以嵌套，在下面的例子里，使用while语句，当一个内部块完成后，如果某个异常在外部块被抛出，内部块上的操作仍然可以回滚（前提是外部块也被atomic装饰过）</p>\n<p><em>atomic被用作装饰器</em><br>\n<u><em>from django.db import transaction</em></u></p>\n<p><u>***@transaction.atomic***</u></p>\n<p><u><em>def viewfunc(request):</em></u></p>\n<p><u><em>do_stuff()</em></u></p>\n<p>创建保存点</p>\n<p><u><em>savepoint()</em></u></p>\n<p>提交保存点</p>\n<p><u><em>savepoint_commit</em>()</u></p>\n<p>回滚保存点</p>\n<p><u><em>savepoint_rollback</em>()</u></p>\n<p>订单并发处理悲观锁乐观锁在冲突比较少的时候采用乐观锁，减少不需要加锁释放锁的开销，可以提高性能。<br>\n在冲突比较多的时候采用悲观锁，减少重复尝试次数，乐观锁重复操作的代价比较大。</p>\n<p><strong>MySQL的MVCC及实现原理</strong></p>\n<p>首先声明，MySQL的测试环境是5.7</p>\n<p>前提概要</p>\n<p><em><u>什么是MVCC?</u></em></p>\n<p>MVCCMVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>\n<p><em><u>什么是当前读和快照读？</u></em></p>\n<p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p>\n<p>当前读像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，</p>\n<p><em><u>为什么叫当前读？</u></em></p>\n<p>就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁快照读像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>\n<p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现当前读，快照读和MVCC的关系准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。</p>\n<p>而相对而言，当前读就是悲观锁的具体功能实现，要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</p>\n<p><em><u>MVCC能解决什么问题，好处是？</u></em></p>\n<p>数据库并发场景有三种，分别为：</p>\n<p>读-读：不存在任何问题，也不需要并发控制</p>\n<p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，</p>\n<p>幻读，不可重复读写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</p>\n<p><em><u>MVCC带来的好处是？</u></em></p>\n<p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题小结一下总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题而提出的解决方案，所以在数据库中有了MVCC，所以我们可以形成两个组合：</p>\n<p>MVCC + 悲观锁MVCC解决读写冲突，悲观锁解决写写冲突</p>\n<p>MVCC + 乐观锁MVCC解决读写冲突，乐观锁解决写写冲突</p>\n<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题*<u>MYSQL 事务日志</u>*</p>\n<p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>\n<p>MySQL Innodb中跟数据持久性、一致性有关的日志，有以下几种：</p>\n<p>**1.**Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的Redo Log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。</p>\n<p>**<u>2.</u>**Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC</p>\n<p><u><em>MVCC的实现原理</em></u></p>\n<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念隐式字段每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>\n<p>DB_TRX_ID 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务IDDB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了<br>\n如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本undo日志</p>\n<p>undo log主要分为两种：</p>\n<p>insert undo log代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>\n<p>update undo log事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除purge</p>\n<p>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见即当前记录没有相关活跃事务在操作时，那么这条记录一定是可以被安全清除的。对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p>\n<p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL<br>\n二、 现在来了一个事务1对该记录的name做出了修改，改为Tom在事务1修改该行(记录)数据时，数据库会先对该行加排他锁然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它事务提交后，释放锁</p>\n<p>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁在事务2修改该行数据时，数据库也先为该行加锁然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录事务提交，释放锁<br>\n从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）Read View(读视图)</p>\n<p><em><u>什么是Read View?</u></em></p>\n<p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>\n<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本那么这个判断条件是什么呢？</p>\n<p>如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性。</p>\n<p>trx_list（名字我随便取的）一个数值列表，用来维护Read View生成时刻系统正活跃的事务IDup_limit_id记录trx_list列表中事务ID最小的IDlow_limit_idReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1，首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断。接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的。</p>\n<p>整体流程</p>\n<p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了整体的流程是怎么样的呢？我们可以模拟一下：</p>\n<p>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list。</p>\n<p>事务1事务2事务3事务4事务开始事务开始事务开始事务开始………修改且已提交进行中快照读进行中………</p>\n<p>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者 ) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图：</p>\n<p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。<br>\n所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p>\n<p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p>\n<p><strong><u><em>MVCC相关问题</em></u></strong></p>\n<p><u><em>RR是如何在RC级的基础上解决不可重复读的？</em></u></p>\n<p>当前读和快照读在RR级别下的区别：</p>\n<p>表1:事务A事务B开启事务开启事务快照读(无影响)查询金额为500快照读查询金额为500更新金额为400提交事务select 快照读金额为500select lock in share mode当前读金额为400在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400。</p>\n<p>表2:事务A事务B开启事务开启事务快照读（无影响）查询金额为500更新金额为400提交事务select 快照读金额为400select lock in share mode当前读金额为400。</p>\n<p>而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力，我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的。</p>\n<p><em><u>RC,RR级别下的InnoDB快照读有什么不同？</u></em></p>\n<p>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见。而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p>\n<p><strong><u>MVCC原理：</u></strong></p>\n<p>MVCC（ Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。 READ COMMITTD、 REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同， READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>\n","description":"MySQL定义了4类隔离级别，包括一些具体规则，用来限定事物内外的哪些改变时可见的，哪些改变时不可见的，低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 第一类： Read Uncommitted(读取未提交的内容)事务A/事务...","title":"mysql事务隔离级别及MVCC","tags":[],"feature":"https://esinew.github.io//post-images/mysql-shi-wu-ge-chi-ji-bie-ji-mvcc.png","link":"https://esinew.github.io/post/mysql-shi-wu-ge-chi-ji-bie-ji-mvcc/","stats":{"text":"23 min read","time":1339000,"words":6299,"minutes":23},"isTop":false,"toc":"","date":"2020-06-24 09:43:32","dateFormat":"2020-06-24"},{"fileName":"mysql-shu-ju-ku-yi","abstract":"","description":"mysql默认的存储引擎：InnoDB InnoDB(其行锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制) MyISAM表最适合大量的数据读而少量数据更新的混合操作，或者使用压缩的只读表。 MEMORY存储引擎适合存储非...","title":"MySQL数据库（一）","tags":[],"feature":"https://esinew.github.io//post-images/mysql-shu-ju-ku-yi.jpg","link":"https://esinew.github.io/post/mysql-shu-ju-ku-yi/","stats":{"text":"5 min read","time":240000,"words":1150,"minutes":5},"isTop":false,"toc":"","date":"2020-06-24 02:27:13","dateFormat":"2020-06-24"},{"fileName":"bean-you-hua-ji-threadlocal","abstract":"<p>[TOC]</p>\n<h2 id=\"bean注解及优化方案\"><strong>@Bean注解</strong>（及优化方案）</h2>\n<p>银行开户的场景。</p>\n<p>银行需要将用户的信用等级，使用记录信息发送给用户。</p>\n<p>接口分析</p>\n<p>1:查询信用等级接口</p>\n<p>2:查询使用记录的接口</p>\n<p>3:发送邮件(需配置<code>smtp</code>)</p>\n<p>要求  各个接口相互独立，任意一个接口的实现被新文件替换，都不能影响其他接口的使用。</p>\n<p>一：   传统的编程方式</p>\n<p>1: 实现各个接口</p>\n<p>2: 将接口组织在一起组成服务</p>\n<h2 id=\"spring-创建bean的时机\"><strong>Spring 创建bean的时机</strong></h2>\n<p>默认在启动spring容器的时候，spring容器配置文件中的类就已经创建完成对象了<br>\n在<bean>中添加属性<code>lazy-init</code>，默认值为false。</p>\n<p>​          <u><em>true 在<code>context.getBean</code>的时候才要创建对象</em></u><br>\n​            * 优点<br>\n​                   如果该bean中有大数据存在，则什么时候<code>context.getBean</code>,什么时候创建对象<br>\n​                   可以防止数据过早的停留在内存中，做到了懒加载<br>\n​            * 缺点<br>\n​                   如果spring配置文件中，该bean的配置有错误，那么在tomcat容器启动的时候，发现不了<br>\n​          <u><em>false 在启动spring容器的时候创建对象</em></u><br>\n​            * 优点<br>\n​                   如果在启动tomcat时要启动spring容器，<br>\n​                   那么如果spring容器会错误，这个时候tomcat容器不会正常启动<br>\n​            * 缺点<br>\n​                    如果存在大量的数据，会过早的停留在内存中</p>\n<h2 id=\"spring-bean的作用域bean的作用域不同需要进行选择及优化\"><strong>Spring Bean的作用域</strong>（bean的作用域不同，需要进行选择及优化）</h2>\n<p>在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。</p>\n<p>目前Spring Bean的作用域或者说范围主要有五种。</p>\n<figure data-type=\"image\" tabindex=\"1\"><img src=\"C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200622225321476.png\" alt=\"image-20200622225321476\" loading=\"lazy\"></figure>\n<h3 id=\"u1被声明为singletton的beanu\"><strong><u><em>（1）被声明为<code>singletton</code>的bean</em></u></strong></h3>\n<p>如果bean的作用域的属性被声明为singleton，那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。</p>\n<p>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，singleton作用域是Spring中的缺省作用域。你可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示：</p>\n<pre><code>&lt;!-- A bean definition with singleton scope --&gt;\n&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt;\n    &lt;!-- collaborators and configuration for this bean go here --&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>单例的例子</p>\n<p>1.首先创建一个bean。</p>\n<pre><code>package com.spring.demo;\npublic class  SingletonBean{\n   private String message;\n   public void setMessage(String message){\n      this.message  = message;\n   }\n   public void getMessage(){\n      System.out.println(&quot;Your Message : &quot; + message);\n   }\n}\n</code></pre>\n<p>2.在Spring的配置文件中配置该bean。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n \n    &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;\n    &lt;!-- 或者 --&gt;\n    &lt;!--  &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; &gt;&lt;/bean&gt; --&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>测试该Bean是否为单例的。</p>\n<pre><code>package com.spring.demo;\n \nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.junit.Test;\n \npublic class TestBean {\n \n    @Test\n    public void textUser()\n    {\n        //1.获取spring文件\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean.xml&quot;);\n        //2.由配置文件返回对象\n        SingletonBean singletonBeanA = (SingletonBean)context.getBean(&quot;SingletonBean&quot;);\n        singletonBeanA.setMessage(&quot;I'm object A&quot;);\n        singletonBeanA.getMessage();\n        SingletonBean singletonBeanB = (SingletonBean)context.getBean(&quot;SingletonBean&quot;);\n        singletonBeanB.getMessage();\n    }\n}\n</code></pre>\n<p>运行结果：</p>\n<figure data-type=\"image\" tabindex=\"2\"><img src=\"C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200622232041433.png\" alt=\"image-20200622232041433\" loading=\"lazy\"></figure>\n<h3 id=\"u2被声明为prototype的beanu\"><strong><u><em>（2）被声明为prototype的bean</em></u></strong></h3>\n<p>当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>\n<p>prototype的例子。</p>\n<p>还是上面的代码。其他代码不变，把Bean.xml文件中bean的作用域由singleton改为prototype。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n \n    &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\n   \n&lt;/beans&gt;\n</code></pre>\n<p>执行代码，程序的执行结果为：</p>\n<figure data-type=\"image\" tabindex=\"3\"><img src=\"C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200622232251010.png\" alt=\"image-20200622232251010\" loading=\"lazy\"></figure>\n<p>从图上可以看出在SingletonBeanA中设置的参数值在SingletonBeanB就获取不到了，说明这两个对象现在返回的就不是同一个对象实例。</p>\n<h3 id=\"u3使用注解定义bean的作用域u\"><em><strong><u>（3）使用注解定义bean的作用域</u></strong></em></h3>\n<p>除了在Bean.xml文件中定义bean的作用域之外，还可以使用注解来定义 bean 的作用域。</p>\n<p>1.在Bean中加上注解。</p>\n<pre><code>package com.spring.demo;\n \nimport org.springframework.context.annotation.Scope;;\nimport org.springframework.stereotype.Component;\n \n@Component(&quot;SingletonBean&quot;)\n@Scope(&quot;prototype&quot;)\npublic class SingletonBean {\n    private String message;\n    public void setMessage(String message){\n        this.message  = message;\n    }\n    public void getMessage(){\n        System.out.println(&quot;Your Message : &quot; + message);\n    }\n}\n</code></pre>\n<p>@Component(&quot;<code>SingletonBean</code>&quot;)注解是告诉Spring这是一个bean。<br>\n@Scope(&quot;prototype&quot;) 注解是告诉Spring该bean的作用域是prototype。</p>\n<p>2.<code>bean.xml</code>文件修改一下。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;\n   \n    &lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt;\n \n&lt;/beans&gt;\n</code></pre>\n<p>&lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt;就是扫描com.spring.demo包中的所有类的注解。</p>\n<p>测试代码不用变，运行测试。</p>\n<figure data-type=\"image\" tabindex=\"4\"><img src=\"C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200622233633950.png\" alt=\"image-20200622233633950\" loading=\"lazy\"></figure>\n<p>和在bean.xml中直接定义bean和其作用域是一样的效果。其他作用域也可以使用注解方式声明bean的作用域。</p>\n<p>request,session和application这三个作用域都是基于web的Spring WebApplicationContext实现的，只有在web环境下（比如XmlWebApplicationContext）中才能使用。<br>\n如果开发者仅仅在常规的Spring IoC容器中比如ClassPathXmlApplicationContext在中使用这些作用域，那么将会抛出一个IllegalStateException来说明使用了未知的作用域。</p>\n<p>也就是当用户使用Spring的WebApplicationContext时，除了使用常规的singleton和prototype作用域之外，还可以使用另外3种Bean的作用域，即request,session和application。</p>\n<p>在使用Web应用环境相关的Bean作用域时，必须在Web容器中进行一些额外的配置：</p>\n<p>1.如果开发者使用了Spring Web MVC框架的话，每一个请求都会通过Spring的DispatcherServlet来处理，也就没有其他特殊的初始化配置，就不需要配置了。DispatcherServlet已经包含了相关的状态。</p>\n<p>2.如果开发者使用的是低版本Web容器比如Servlet 2.5的web容器，请求不是通过Spring的DispatcherServlet（比如JSF或者Struts）来处理的。那么开发者需要注册org.springframework.web.context.request.RequestContextListener或者ServletRequestListener。可以在web.xml中增加如下的Listener声明：</p>\n<pre><code>&lt;web-app&gt;\n    ...\n    &lt;listener&gt;\n        &lt;listener-class&gt;\n            org.springframework.web.context.request.RequestContextListener\n        &lt;/listener-class&gt;\n    &lt;/listener&gt;\n    ...\n&lt;/web-app&gt;\n</code></pre>\n<p>ServletContextListener只负责监听web容器启动和关闭的事件，而RequestContextListener实现了ServletRequestListener监听器接口，该监听器监听http请求事件。Web服务器接收到的每一次请求都会通知该监听器。</p>\n<p>而在Servlet 3.0以后，这些都能够通过WebApplicationInitializer接口来实现配置。</p>\n<p>3.如果不使用Listener，也可以考虑使用Spring的RequestContextFilter，通过http过滤器进行配置，在url-pattern中对所有的页面进行过滤。也是在web.xml中进行配置。</p>\n<pre><code>&lt;web-app&gt;\n    ...\n    &lt;filter&gt;\n        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n    ...\n&lt;/web-app&gt;\n</code></pre>\n<p>配置完这些额外的配置之后，就可以使用另外的3种bean的作用域了。</p>\n<h3 id=\"u4请求作用域u\"><em><strong><u>（4）请求作用域</u></strong></em></h3>\n<p>请求作用域参考如下的Bean定义</p>\n<pre><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;\n</code></pre>\n<p>Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。<br>\n当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p>\n<h3 id=\"u5会话作用域u\"><em><strong><u>（5）会话作用域</u></strong></em></h3>\n<p>会话作用域参考如下的Bean定义</p>\n<pre><code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;\n</code></pre>\n<p>Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。</p>\n<p>Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p>\n<h3 id=\"u6全局作用域u\"><em><strong><u>（6）全局作用域</u></strong></em></h3>\n<p>全局作用域参考如下的Bean定义</p>\n<pre><code>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.foo.AppPreferences&quot; scope=&quot;application&quot;/&gt;\n</code></pre>\n<p>Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处：</p>\n<p>1.application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。</p>\n<p>2.application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。</p>\n<p>接下来再来简单的学习下在Spring当中如何自定义作用域：</p>\n<p>在Spring 2.0中，Spring的Bean作用域机制是可以扩展的，这意味着，你不仅可以使用Spring提供的预定义Bean作用域，还可以定义自己的作用域，甚至重新定义现有的作用域（不提倡这么做，而且你不能覆盖内置的singleton和prototype作用域）</p>\n<h3 id=\"7自定义作用域\"><em><strong>（7）自定义作用域</strong></em></h3>\n<p>除了使用Spring已经定义好的作用域之外，还可以自定义bean的作用域。</p>\n<p>要底线自定义作用域</p>\n<p>1.首先需要实现自定义Scope类。</p>\n<p>首先要先实现org.springframework.beans.factory.config.Scope这个接口，要将自定义scope集成到Spring容器当中就必须要实现这个接口。接口中有两个常用的方法，分别用于底层存储机制获取和删除这个对象。</p>\n<p>2.在实现一个或多个自定义Scope并测试通过之后，接下来便是如何让Spring容器来识别新的作用域。registerScope方法就是在Spring容器中用来注册新的作用域。</p>\n<p>void registerScope(String scopeName, Scope scope);</p>\n<p>其中：第一个参数是与作用域相关的全局唯一的名称，第二个参数是准备实现的作用域的实例，就是实现Scope接口的实例。</p>\n<p>比如实现Scope接口的类为SimpleThreadScope，要实现的自定义的bean的作用域的名称为“thread”,那就可以这么写</p>\n<pre><code>    Scope threadScope = new SimpleThreadScope();\n    beanFactory.registerScope(&quot;thread&quot;, threadScope);\n</code></pre>\n<p>3.在实现和注册自定义的scope类之后，就可以通过如下类似的Bean定义来使用自定义的<code>Scope</code>:</p>\n<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;thread&quot;&gt;\n</code></pre>\n<p>另外，在自定义的Scope中，开发者也不限于仅仅通过编程方式来实现自定义的bean的作用域，也可以在Spring的配置文件中配置和使用自定义作用域和，比如配置CustomScopeConfigurer实例实现自定义的作用域，声明作用域名称为“thread”，就可以在xml文件中做如下类似的定义。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n \n    &lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt;\n        &lt;property name=&quot;scopes&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;thread&quot;&gt;\n                    &lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&gt;\n                &lt;/entry&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot; scope=&quot;thread&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;Rick&quot;/&gt;\n        &lt;aop:scoped-proxy/&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;\n        &lt;property name=&quot;bar&quot; ref=&quot;bar&quot;/&gt;\n    &lt;/bean&gt;\n \n&lt;/beans&gt;\n</code></pre>\n<h1 id=\"spring的并发问题有状态bean和无状态bean\">Spring的并发问题——有状态Bean和无状态Bean</h1>\n<p><strong>一、有状态和无状态</strong></p>\n<p><strong>有状态会话bean</strong> ：每个用户有自己特有的一个实例，在用户的生存期内，bean保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean的生命期也告结束。即每个用户最初都会得到一个初始的bean。简单来说，有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是<strong>非线程安全</strong>的。</p>\n<p><strong>无状态会话bean</strong> ：bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean  的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean  并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。简单来说，无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是<strong>线程安全</strong>的。</p>\n<figure data-type=\"image\" tabindex=\"5\"><img src=\"http://5b0988e595225.cdn.sohucs.com/images/20190909/d032cf426aa945a8b2dd3ab9e6acf82d.gif\" alt=\"img\" loading=\"lazy\"></figure>\n<p>一个有状态的bean</p>\n<p><strong>二、解决有状态bean的线程安全问题</strong></p>\n<p>Spring对bean的配置中有四种配置方式，我们只说其中两种：singleton单例模式、prototype原型模式。</p>\n<bean id=\"testManager\" class=\"com.sw.TestManagerImpl\" scope=\"singleton\" />\n<bean id=\"testManager\" class=\"com.sw.TestManagerImpl\" scope=\"prototype\" />\n<p>默认的配置是singleton。</p>\n<p>singleton表示该bean全局只有一个实例。</p>\n<p>prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的Bean。</p>\n<p>如果对有状态的bean使用了singleton的话会出现线程安全问题。</p>\n<figure data-type=\"image\" tabindex=\"6\"><img src=\"C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623153405489.png\" alt=\"image-20200623153405489\" loading=\"lazy\"></figure>\n<p>例如上面的例子</p>\n<p>如果有两个用户同时访问</p>\n<p>假定为user1,user2</p>\n<p>当user1 调用到程序中的1步骤的时候，该Bean的私有变量user被付值为user1</p>\n<p>当user1的程序走到2步骤的时候，该Bean的私有变量user被重新付值为user1_create</p>\n<p>理想的状况，当user1走到3步骤的时候，私有变量user应该为user1_create;</p>\n<p>但如果在user1调用到3步骤之前，user2开始运行到了1步骤了，由于单态的资源共享，则私有变量user被修改为user2</p>\n<p>这种情况下，user1的步骤3用到的user.getId()实际用到是user2的对象。</p>\n<p>对于这种情况我们可以这样解决</p>\n<p>1.将有状态的bean配置成prototype模式，让每一个线程都创建一个prototype实例。但是这样会产生很多的实例消耗较多的内存空间。</p>\n<p>2.使用ThreadLocal变量，为每一条线程设置变量副本。</p>\n<p>使用ThreadLocal的例子：</p>\n<p>例如，我们有一个银行的BankDAO类和一个个人账户的PeopleDAO类，现在需要个人向银行进行转账，在PeopleDAO类中有一个账户减少的方法，BankDAO类中有一个账户增加的方法，那么这两个方法在调用的时候必须使用同一个Connection数据库连接对象，如果他们使用两个Connection对象，则会开启两段事务，可能出现个人账户减少而银行账户未增加的现象。使用同一个Connection对象的话，在应用程序中可能会设置为一个全局的数据库连接对象，从而避免在调用每个方法时都传递一个Connection对象。问题是当我们把Connection对象设置为全局变量时，你不能保证是否有其他线程会将这个Connection对象关闭，这样就会出现线程安全问题。解决办法就是在进行转账操作这个线程中，使用ThreadLocal中获取Connection对象，这样，在调用个人账户减少和银行账户增加的线程中，就能从ThreadLocal中取到同一个Connection对象，并且这个Connection对象为转账操作这个线程独有，不会被其他线程影响，保证了线程安全性。</p>\n<h1 id=\"threadlocal作用-场景-原理解决bean共享作用域资源占用及线程冲突问题\">ThreadLocal作用、场景、原理*（解决bean共享作用域资源占用及线程冲突问题）*</h1>\n<h3 id=\"1threadlocal-是什么\">1.ThreadLocal 是什么？</h3>\n<p>在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>\n<p>ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p>\n<p>在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<T>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>\n<pre><code> * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID)\n</code></pre>\n<h3 id=\"11threadlocal-的作用\">1.1.ThreadLocal 的作用？</h3>\n<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>\n<h3 id=\"2android源码中也可以看到threadlocal的身影\">2.Android源码中也可以看到ThreadLocal的身影</h3>\n<p>这里以andorid 源码的Handler为例子。看看Handker是怎么用ThreadLocal的。Handler就必须获取当前线程的 Looper 对象，而每一个线程的 Looper 是不一致的。因为每一个线程都会有一个 Looper 对象，因此使用 ThradLocal 去保存和获取当前线程的 Looper 就可以达到这个的效果。</p>\n<h3 id=\"21-looper-内部的关于在-threadlocal-中存储-looper-和-获取-looper-的源码\">2.1. Looper 内部的关于在 ThreadLocal 中存储 Looper 和 获取 Looper 的源码。</h3>\n<pre><code>//Looper.prepare();\n​\nprivate static void prepare(boolean quitAllowed) {\n if (sThreadLocal.get() != null) {\n throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);\n }\n //将创建的 Looper 对象保存到 sThreadLocal 中。\n sThreadLocal.set(new Looper(quitAllowed));\n}\n​\n​\n//从 ThreadLocal 取出 Looper 对象\npublic static @Nullable Looper myLooper() {\n return sThreadLocal.get();\n}\n</code></pre>\n<h3 id=\"3threadlocal的内部原理\">3.ThreadLocal的内部原理</h3>\n<p>我们从源码中了解ThreadLocal的原理，下面来看一下具体ThreadLocal是如何实现的。</p>\n<p>ThreadLocal类中提供了几个方法：</p>\n<p>1.public T get() { }</p>\n<p>2.public void set(T value) { }</p>\n<p>3.public void remove() { }</p>\n<p>4.protected T initialValue(){ }</p>\n<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。</p>\n<h3 id=\"31先看下get方法源码的实现\">3.1.先看下get方法源码的实现</h3>\n<pre><code class=\"language-java\"> * Returns the value in the current thread's copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread's value of this thread-local\n */\npublic T get() {\n Thread t = Thread.currentThread();\n ThreadLocalMap map = getMap(t);\n if (map != null) {\n ThreadLocalMap.Entry e = map.getEntry(this);\n if (e != null) {\n @SuppressWarnings(&quot;unchecked&quot;)\n T result = (T)e.value;\n return result;\n }\n }\n return setInitialValue();\n}\n\n/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n T value = initialValue();\n Thread t = Thread.currentThread();\n ThreadLocalMap map = getMap(t);\n if (map != null)\n map.set(this, value);\n else\n createMap(t, value);\n return value;\n}\n</code></pre>\n<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是 this，而不是当前线程t。 如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。</p>\n<p><strong>看看getMap(t)做了些什么</strong></p>\n<pre><code class=\"language-java\"> * Get the map associated with a ThreadLocal. Overridden in\n * InheritableThreadLocal.\n *\n * @param  t the current thread\n * @return the map\n */\n ThreadLocalMap getMap(Thread t) {\n return t.threadLocals;\n }\n</code></pre>\n<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。 那么我们继续取Thread类中取看一下成员变量threadLocals是什么?继续查看源码</p>\n<pre><code class=\"language-java\"> * ThreadLocalMap is a customized hash map suitable only for\n * maintaining thread local values. No operations are exported\n * outside of the ThreadLocal class. The class is package private to\n * allow declaration of fields in class Thread.  To help deal with\n * very large and long-lived usages, the hash table entries use\n * WeakReferences for keys. However, since reference queues are not\n * used, stale entries are guaranteed to be removed only when\n * the table starts running out of space.\n */\n static class ThreadLocalMap {\n\n /**\n * The entries in this hash map extend WeakReference, using\n * its main ref field as the key (which is always a\n * ThreadLocal object).  Note that null keys (i.e. entry.get()\n * == null) mean that the key is no longer referenced, so the\n * entry can be expunged from table.  Such entries are referred to\n * as &quot;stale entries&quot; in the code that follows.\n */\n static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n /** The value associated with this ThreadLocal. */\n Object value;\n\n Entry(ThreadLocal&lt;?&gt; k, Object v) {\n super(k);\n value = v;\n }\n }\n\n //省略....\n }\n</code></pre>\n<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现。</p>\n<p><strong>再看setInitialValue()方法</strong></p>\n<p>setInitialValue()很容易理解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现。</p>\n<pre><code class=\"language-java\"> * Create the map associated with a ThreadLocal. Overridden in\n * InheritableThreadLocal.\n *\n * @param t the current thread\n * @param firstValue value for the initial entry of the map\n */\n void createMap(Thread t, T firstValue) {\n t.threadLocals = new ThreadLocalMap(this, firstValue);\n }\n</code></pre>\n<p><strong>如果使用ThreadLocal时，先进行get之前，必须先set，否则会报空指针异常</strong></p>\n<pre><code class=\"language-java\">public class ThreadLocalExsample {\n\n    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;&gt;();\n    public void set() {\n        longLocal.set(Thread.currentThread().getId());\n    }\n    public long getLong() {\n        return longLocal.get();\n    }\n public static void main(String[] args) {\n        ThreadLocalExsample test = new ThreadLocalExsample();\n        //注意:没有set之前，直接get，报null异常了\n        System.out.println(&quot;-------threadLocal value-------&quot; + test.getLong());\n    }\n}\n</code></pre>\n<p><strong>ThreadLocal的应用场景# 数据库连接</strong></p>\n<pre><code class=\"language-java\"> public Connection initialValue() {\n return DriverManager.getConnection(DB_URL);\n }\n};  \n\npublic static Connection getConnection() {  \n return connectionHolder.get();\n}  \n</code></pre>\n<p><strong>ThreadLocal的应用场景# Session管理</strong></p>\n<pre><code class=\"language-java\">public static Session getSession() throws InfrastructureException {  \n Session s = (Session) threadSession.get();\n try {\n if (s == null) {\n s = getSessionFactory().openSession();\n threadSession.set(s);\n }\n } catch (HibernateException ex) {\n throw new InfrastructureException(ex);\n }\n return s;\n}\n</code></pre>\n<p><strong>ThreadLocal的应用场景# 多线程</strong></p>\n<pre><code class=\"language-java\"> * 描述 Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。\n * 因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，\n * 它们也无法访问到对方的ThreadLocal变量。\n */\npublic class ThreadLocalExsample {\n\n /**\n * 创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run()方法，\n * 并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并且调用的set()方法被同步了，\n * 则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是一个ThreadLocal对象，\n * 因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同的值。\n */\n public static class MyRunnable implements Runnable {\n /**\n * 例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。\n * 虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的\n * set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，\n * 他们仍然无法访问到对方的值。\n */\n private ThreadLocal threadLocal = new ThreadLocal();\n @Override\n public void run() {\n //一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值\n threadLocal.set((int) (Math.random() * 100D));\n try {\n Thread.sleep(2000);\n } catch (InterruptedException e) {\n }\n //可以通过下面方法读取保存在ThreadLocal变量中的值\n System.out.println(&quot;-------threadLocal value-------&quot;+threadLocal.get());\n }\n }\n\n public static void main(String[] args) {\n MyRunnable sharedRunnableInstance = new MyRunnable();\n Thread thread1 = new Thread(sharedRunnableInstance);\n Thread thread2 = new Thread(sharedRunnableInstance);\n thread1.start();\n thread2.start();\n }\n}\n\n运行结果\n-------threadLocal value-------38\n-------threadLocal value-------88\n</code></pre>\n<h3 id=\"得出结论\">得出结论</h3>\n<blockquote>\n<p>ThreadLocal 中 set 和 get 操作的都是对应线程的 table数组，因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。</p>\n</blockquote>\n<h2 id=\"总结\">总结</h2>\n<p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>\n<ol>\n<li>实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</li>\n<li>为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</li>\n<li>在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</li>\n</ol>\n<p><u>***转载评论：***</u></p>\n<p><a href=\"https://www.jianshu.com/u/389b0c04dd32\">阿拉斯丁_a9d8</a></p>\n<p>public 【long】 getLong() {<br>\nreturn longLocal.get();<br>\n}</p>\n<p>把long的位置改成Long，就不会报空指针异常了。这个空指针异常和ThreadLocal没关系。</p>\n<p><a href=\"https://www.jianshu.com/u/8840e46f8fa4\">WaterYuan</a></p>\n<p>在进行get之前，不比先set，不会空指针异常，只不过get得到null而已</p>\n<p>```<br>\npublic T get() {<br>\nThread t = Thread.currentThread();<br>\nThreadLocalMap map = getMap(t);<br>\nif (map != null) {<br>\nThreadLocalMap.Entry e = map.getEntry(this);<br>\nif (e != null) {<br>\n@SuppressWarnings(&quot;unchecked&quot;)<br>\nT result = (T)e.value;<br>\nreturn result;<br>\n}<br>\n}<br>\nreturn setInitialValue();<br>\n}<br>\n```</p>\n","description":"[TOC] @Bean注解（及优化方案） 银行开户的场景。 银行需要将用户的信用等级，使用记录信息发送给用户。 接口分析 1:查询信用等级接口 2:查询使用记录的接口 3:发送邮件(需配置smtp) 要求 各个接口相互独立，任意一个接口的...","title":"@bean优化及ThreadLocal","tags":[],"feature":"https://esinew.github.io//post-images/bean-you-hua-ji-threadlocal.jpg","link":"https://esinew.github.io/post/bean-you-hua-ji-threadlocal/","stats":{"text":"29 min read","time":1704000,"words":6810,"minutes":29},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#bean%E6%B3%A8%E8%A7%A3%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88\"><strong>@Bean注解</strong>（及优化方案）</a></li>\n<li><a href=\"#spring-%E5%88%9B%E5%BB%BAbean%E7%9A%84%E6%97%B6%E6%9C%BA\"><strong>Spring 创建bean的时机</strong></a></li>\n<li><a href=\"#spring-bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%90%8C%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9%E5%8F%8A%E4%BC%98%E5%8C%96\"><strong>Spring Bean的作用域</strong>（bean的作用域不同，需要进行选择及优化）</a>\n<ul>\n<li><a href=\"#u1%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BAsingletton%E7%9A%84beanu\"><strong><u><em>（1）被声明为<code>singletton</code>的bean</em></u></strong></a></li>\n<li><a href=\"#u2%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BAprototype%E7%9A%84beanu\"><strong><u><em>（2）被声明为prototype的bean</em></u></strong></a></li>\n<li><a href=\"#u3%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9Fu\">***<u>（3）使用注解定义bean的作用域</u>***</a></li>\n<li><a href=\"#u4%E8%AF%B7%E6%B1%82%E4%BD%9C%E7%94%A8%E5%9F%9Fu\">***<u>（4）请求作用域</u>***</a></li>\n<li><a href=\"#u5%E4%BC%9A%E8%AF%9D%E4%BD%9C%E7%94%A8%E5%9F%9Fu\">***<u>（5）会话作用域</u>***</a></li>\n<li><a href=\"#u6%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9Fu\">***<u>（6）全局作用域</u>***</a></li>\n<li><a href=\"#7%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%9C%E7%94%A8%E5%9F%9F\">***（7）自定义作用域***</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#spring%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%9C%89%E7%8A%B6%E6%80%81bean%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81bean\">Spring的并发问题——有状态Bean和无状态Bean</a></li>\n<li><a href=\"#threadlocal%E4%BD%9C%E7%94%A8-%E5%9C%BA%E6%99%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E5%86%B3bean%E5%85%B1%E4%BA%AB%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98\">ThreadLocal作用、场景、原理*（解决bean共享作用域资源占用及线程冲突问题）*</a><br>\n*\n<ul>\n<li><a href=\"#1threadlocal-%E6%98%AF%E4%BB%80%E4%B9%88\">1.ThreadLocal 是什么？</a></li>\n<li><a href=\"#11threadlocal-%E7%9A%84%E4%BD%9C%E7%94%A8\">1.1.ThreadLocal 的作用？</a></li>\n<li><a href=\"#2android%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0threadlocal%E7%9A%84%E8%BA%AB%E5%BD%B1\">2.Android源码中也可以看到ThreadLocal的身影</a></li>\n<li><a href=\"#21-looper-%E5%86%85%E9%83%A8%E7%9A%84%E5%85%B3%E4%BA%8E%E5%9C%A8-threadlocal-%E4%B8%AD%E5%AD%98%E5%82%A8-looper-%E5%92%8C-%E8%8E%B7%E5%8F%96-looper-%E7%9A%84%E6%BA%90%E7%A0%81\">2.1. Looper 内部的关于在 ThreadLocal 中存储 Looper 和 获取 Looper 的源码。</a></li>\n<li><a href=\"#3threadlocal%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86\">3.ThreadLocal的内部原理</a></li>\n<li><a href=\"#31%E5%85%88%E7%9C%8B%E4%B8%8Bget%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0\">3.1.先看下get方法源码的实现</a></li>\n<li><a href=\"#%E5%BE%97%E5%87%BA%E7%BB%93%E8%AE%BA\">得出结论</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-23 17:31:45","dateFormat":"2020-06-23"},{"fileName":"wei-shi-me-yao-yong-spring-bean","abstract":"","description":"为什么要用spring bean？ [TOC] 什么是bean? EJB是Enterprise Java Bean的缩写，一个Bean扮演着应用程序素材的角色。它包含有一个functional interface，一个life-cycle ...","title":"为什么要用spring bean？","tags":[],"feature":"https://esinew.github.io//post-images/wei-shi-me-yao-yong-spring-bean.jpg","link":"https://esinew.github.io/post/wei-shi-me-yao-yong-spring-bean/","stats":{"text":"17 min read","time":983000,"words":4011,"minutes":17},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8spring-bean\">为什么要用spring bean？</a>\n<ul>\n<li><a href=\"#bean-%E5%9F%BA%E7%A1%80%E5%A3%B0%E6%98%8E\">@Bean 基础声明</a></li>\n<li><a href=\"#bean-%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8\">@Bean 基本构成及其使用</a></li>\n<li><a href=\"#bean-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E4%BA%A7%E7%94%9F%E7%9A%84%E7%81%AB%E8%8A%B1\">@Bean 注解与其他注解产生的火花</a>\n<ul>\n<li><a href=\"#profile-%E6%B3%A8%E8%A7%A3\">@Profile 注解</a></li>\n<li><a href=\"#scope-%E6%B3%A8%E8%A7%A3\">@Scope 注解</a></li>\n<li><a href=\"#lazy-%E6%B3%A8%E8%A7%A3\">@Lazy 注解</a></li>\n<li><a href=\"#dependson-%E6%B3%A8%E8%A7%A3\">@DependsOn 注解</a></li>\n<li><a href=\"#primary-%E6%B3%A8%E8%A7%A3\">@Primary 注解</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-23 17:29:47","dateFormat":"2020-06-23"}],"tags":[],"menus":[{"link":"/","name":"首页","openType":"Internal"},{"link":"/archives","name":"归档","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"},{"link":"/post/about","name":"关于","openType":"Internal"}],"themeConfig":{"themeName":"gridea-theme-vant-master","postPageSize":10,"archivesPageSize":50,"siteName":"每一步都是新生","siteDescription":"温故而知新","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://esinew.github.io/","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{},"utils":{"now":1593849132616}}
