{"posts":[{"title":"@bean优化及ThreadLocal","content":"[TOC] @Bean注解（及优化方案） 银行开户的场景。 银行需要将用户的信用等级，使用记录信息发送给用户。 接口分析 1:查询信用等级接口 2:查询使用记录的接口 3:发送邮件(需配置smtp) 要求 各个接口相互独立，任意一个接口的实现被新文件替换，都不能影响其他接口的使用。 一： 传统的编程方式 1: 实现各个接口 2: 将接口组织在一起组成服务 Spring 创建bean的时机 默认在启动spring容器的时候，spring容器配置文件中的类就已经创建完成对象了 在中添加属性lazy-init，默认值为false。 ​ true 在context.getBean的时候才要创建对象 ​ * 优点 ​ 如果该bean中有大数据存在，则什么时候context.getBean,什么时候创建对象 ​ 可以防止数据过早的停留在内存中，做到了懒加载 ​ * 缺点 ​ 如果spring配置文件中，该bean的配置有错误，那么在tomcat容器启动的时候，发现不了 ​ false 在启动spring容器的时候创建对象 ​ * 优点 ​ 如果在启动tomcat时要启动spring容器， ​ 那么如果spring容器会错误，这个时候tomcat容器不会正常启动 ​ * 缺点 ​ 如果存在大量的数据，会过早的停留在内存中 Spring Bean的作用域（bean的作用域不同，需要进行选择及优化） 在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。 目前Spring Bean的作用域或者说范围主要有五种。 （1）被声明为singletton的bean 如果bean的作用域的属性被声明为singleton，那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。 Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，singleton作用域是Spring中的缺省作用域。你可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示： &lt;!-- A bean definition with singleton scope --&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; 单例的例子 1.首先创建一个bean。 package com.spring.demo; public class SingletonBean{ private String message; public void setMessage(String message){ this.message = message; } public void getMessage(){ System.out.println(&quot;Your Message : &quot; + message); } } 2.在Spring的配置文件中配置该bean。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; &lt;!-- 或者 --&gt; &lt;!-- &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; &gt;&lt;/bean&gt; --&gt; &lt;/beans&gt; 测试该Bean是否为单例的。 package com.spring.demo; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.junit.Test; public class TestBean { @Test public void textUser() { //1.获取spring文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean.xml&quot;); //2.由配置文件返回对象 SingletonBean singletonBeanA = (SingletonBean)context.getBean(&quot;SingletonBean&quot;); singletonBeanA.setMessage(&quot;I'm object A&quot;); singletonBeanA.getMessage(); SingletonBean singletonBeanB = (SingletonBean)context.getBean(&quot;SingletonBean&quot;); singletonBeanB.getMessage(); } } 运行结果： （2）被声明为prototype的bean 当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。 prototype的例子。 还是上面的代码。其他代码不变，把Bean.xml文件中bean的作用域由singleton改为prototype。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 执行代码，程序的执行结果为： 从图上可以看出在SingletonBeanA中设置的参数值在SingletonBeanB就获取不到了，说明这两个对象现在返回的就不是同一个对象实例。 （3）使用注解定义bean的作用域 除了在Bean.xml文件中定义bean的作用域之外，还可以使用注解来定义 bean 的作用域。 1.在Bean中加上注解。 package com.spring.demo; import org.springframework.context.annotation.Scope;; import org.springframework.stereotype.Component; @Component(&quot;SingletonBean&quot;) @Scope(&quot;prototype&quot;) public class SingletonBean { private String message; public void setMessage(String message){ this.message = message; } public void getMessage(){ System.out.println(&quot;Your Message : &quot; + message); } } @Component(&quot;SingletonBean&quot;)注解是告诉Spring这是一个bean。 @Scope(&quot;prototype&quot;) 注解是告诉Spring该bean的作用域是prototype。 2.bean.xml文件修改一下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt; &lt;/beans&gt; &lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt;就是扫描com.spring.demo包中的所有类的注解。 测试代码不用变，运行测试。 和在bean.xml中直接定义bean和其作用域是一样的效果。其他作用域也可以使用注解方式声明bean的作用域。 request,session和application这三个作用域都是基于web的Spring WebApplicationContext实现的，只有在web环境下（比如XmlWebApplicationContext）中才能使用。 如果开发者仅仅在常规的Spring IoC容器中比如ClassPathXmlApplicationContext在中使用这些作用域，那么将会抛出一个IllegalStateException来说明使用了未知的作用域。 也就是当用户使用Spring的WebApplicationContext时，除了使用常规的singleton和prototype作用域之外，还可以使用另外3种Bean的作用域，即request,session和application。 在使用Web应用环境相关的Bean作用域时，必须在Web容器中进行一些额外的配置： 1.如果开发者使用了Spring Web MVC框架的话，每一个请求都会通过Spring的DispatcherServlet来处理，也就没有其他特殊的初始化配置，就不需要配置了。DispatcherServlet已经包含了相关的状态。 2.如果开发者使用的是低版本Web容器比如Servlet 2.5的web容器，请求不是通过Spring的DispatcherServlet（比如JSF或者Struts）来处理的。那么开发者需要注册org.springframework.web.context.request.RequestContextListener或者ServletRequestListener。可以在web.xml中增加如下的Listener声明： &lt;web-app&gt; ... &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; ... &lt;/web-app&gt; ServletContextListener只负责监听web容器启动和关闭的事件，而RequestContextListener实现了ServletRequestListener监听器接口，该监听器监听http请求事件。Web服务器接收到的每一次请求都会通知该监听器。 而在Servlet 3.0以后，这些都能够通过WebApplicationInitializer接口来实现配置。 3.如果不使用Listener，也可以考虑使用Spring的RequestContextFilter，通过http过滤器进行配置，在url-pattern中对所有的页面进行过滤。也是在web.xml中进行配置。 &lt;web-app&gt; ... &lt;filter&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; ... &lt;/web-app&gt; 配置完这些额外的配置之后，就可以使用另外的3种bean的作用域了。 （4）请求作用域 请求作用域参考如下的Bean定义 &lt;bean id=&quot;loginAction&quot; class=&quot;com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt; Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。 当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。 （5）会话作用域 会话作用域参考如下的Bean定义 &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。 Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。 （6）全局作用域 全局作用域参考如下的Bean定义 &lt;bean id=&quot;appPreferences&quot; class=&quot;com.foo.AppPreferences&quot; scope=&quot;application&quot;/&gt; Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处： 1.application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。 2.application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。 接下来再来简单的学习下在Spring当中如何自定义作用域： 在Spring 2.0中，Spring的Bean作用域机制是可以扩展的，这意味着，你不仅可以使用Spring提供的预定义Bean作用域，还可以定义自己的作用域，甚至重新定义现有的作用域（不提倡这么做，而且你不能覆盖内置的singleton和prototype作用域） （7）自定义作用域 除了使用Spring已经定义好的作用域之外，还可以自定义bean的作用域。 要底线自定义作用域 1.首先需要实现自定义Scope类。 首先要先实现org.springframework.beans.factory.config.Scope这个接口，要将自定义scope集成到Spring容器当中就必须要实现这个接口。接口中有两个常用的方法，分别用于底层存储机制获取和删除这个对象。 2.在实现一个或多个自定义Scope并测试通过之后，接下来便是如何让Spring容器来识别新的作用域。registerScope方法就是在Spring容器中用来注册新的作用域。 void registerScope(String scopeName, Scope scope); 其中：第一个参数是与作用域相关的全局唯一的名称，第二个参数是准备实现的作用域的实例，就是实现Scope接口的实例。 比如实现Scope接口的类为SimpleThreadScope，要实现的自定义的bean的作用域的名称为“thread”,那就可以这么写 Scope threadScope = new SimpleThreadScope(); beanFactory.registerScope(&quot;thread&quot;, threadScope); 3.在实现和注册自定义的scope类之后，就可以通过如下类似的Bean定义来使用自定义的Scope: &lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;thread&quot;&gt; 另外，在自定义的Scope中，开发者也不限于仅仅通过编程方式来实现自定义的bean的作用域，也可以在Spring的配置文件中配置和使用自定义作用域和，比如配置CustomScopeConfigurer实例实现自定义的作用域，声明作用域名称为“thread”，就可以在xml文件中做如下类似的定义。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt; &lt;property name=&quot;scopes&quot;&gt; &lt;map&gt; &lt;entry key=&quot;thread&quot;&gt; &lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot; scope=&quot;thread&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Rick&quot;/&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt; &lt;property name=&quot;bar&quot; ref=&quot;bar&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; Spring的并发问题——有状态Bean和无状态Bean 一、有状态和无状态 有状态会话bean ：每个用户有自己特有的一个实例，在用户的生存期内，bean保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean的生命期也告结束。即每个用户最初都会得到一个初始的bean。简单来说，有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。 无状态会话bean ：bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。简单来说，无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。 一个有状态的bean 二、解决有状态bean的线程安全问题 Spring对bean的配置中有四种配置方式，我们只说其中两种：singleton单例模式、prototype原型模式。 默认的配置是singleton。 singleton表示该bean全局只有一个实例。 prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的Bean。 如果对有状态的bean使用了singleton的话会出现线程安全问题。 例如上面的例子 如果有两个用户同时访问 假定为user1,user2 当user1 调用到程序中的1步骤的时候，该Bean的私有变量user被付值为user1 当user1的程序走到2步骤的时候，该Bean的私有变量user被重新付值为user1_create 理想的状况，当user1走到3步骤的时候，私有变量user应该为user1_create; 但如果在user1调用到3步骤之前，user2开始运行到了1步骤了，由于单态的资源共享，则私有变量user被修改为user2 这种情况下，user1的步骤3用到的user.getId()实际用到是user2的对象。 对于这种情况我们可以这样解决 1.将有状态的bean配置成prototype模式，让每一个线程都创建一个prototype实例。但是这样会产生很多的实例消耗较多的内存空间。 2.使用ThreadLocal变量，为每一条线程设置变量副本。 使用ThreadLocal的例子： 例如，我们有一个银行的BankDAO类和一个个人账户的PeopleDAO类，现在需要个人向银行进行转账，在PeopleDAO类中有一个账户减少的方法，BankDAO类中有一个账户增加的方法，那么这两个方法在调用的时候必须使用同一个Connection数据库连接对象，如果他们使用两个Connection对象，则会开启两段事务，可能出现个人账户减少而银行账户未增加的现象。使用同一个Connection对象的话，在应用程序中可能会设置为一个全局的数据库连接对象，从而避免在调用每个方法时都传递一个Connection对象。问题是当我们把Connection对象设置为全局变量时，你不能保证是否有其他线程会将这个Connection对象关闭，这样就会出现线程安全问题。解决办法就是在进行转账操作这个线程中，使用ThreadLocal中获取Connection对象，这样，在调用个人账户减少和银行账户增加的线程中，就能从ThreadLocal中取到同一个Connection对象，并且这个Connection对象为转账操作这个线程独有，不会被其他线程影响，保证了线程安全性。 ThreadLocal作用、场景、原理*（解决bean共享作用域资源占用及线程冲突问题）* 1.ThreadLocal 是什么？ 在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。 在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID) 1.1.ThreadLocal 的作用？ ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 2.Android源码中也可以看到ThreadLocal的身影 这里以andorid 源码的Handler为例子。看看Handker是怎么用ThreadLocal的。Handler就必须获取当前线程的 Looper 对象，而每一个线程的 Looper 是不一致的。因为每一个线程都会有一个 Looper 对象，因此使用 ThradLocal 去保存和获取当前线程的 Looper 就可以达到这个的效果。 2.1. Looper 内部的关于在 ThreadLocal 中存储 Looper 和 获取 Looper 的源码。 //Looper.prepare(); ​ private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } //将创建的 Looper 对象保存到 sThreadLocal 中。 sThreadLocal.set(new Looper(quitAllowed)); } ​ ​ //从 ThreadLocal 取出 Looper 对象 public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 3.ThreadLocal的内部原理 我们从源码中了解ThreadLocal的原理，下面来看一下具体ThreadLocal是如何实现的。 ThreadLocal类中提供了几个方法： 1.public T get() { } 2.public void set(T value) { } 3.public void remove() { } 4.protected T initialValue(){ } get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。 3.1.先看下get方法源码的实现 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread's value of this thread-local */ public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue(); } /** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */ private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } 第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是 this，而不是当前线程t。 如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。 看看getMap(t)做了些什么 * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。 那么我们继续取Thread类中取看一下成员变量threadLocals是什么?继续查看源码 * ThreadLocalMap is a customized hash map suitable only for * maintaining thread local values. No operations are exported * outside of the ThreadLocal class. The class is package private to * allow declaration of fields in class Thread. To help deal with * very large and long-lived usages, the hash table entries use * WeakReferences for keys. However, since reference queues are not * used, stale entries are guaranteed to be removed only when * the table starts running out of space. */ static class ThreadLocalMap { /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } //省略.... } 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现。 再看setInitialValue()方法 setInitialValue()很容易理解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现。 * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } 如果使用ThreadLocal时，先进行get之前，必须先set，否则会报空指针异常 public class ThreadLocalExsample { ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;&gt;(); public void set() { longLocal.set(Thread.currentThread().getId()); } public long getLong() { return longLocal.get(); } public static void main(String[] args) { ThreadLocalExsample test = new ThreadLocalExsample(); //注意:没有set之前，直接get，报null异常了 System.out.println(&quot;-------threadLocal value-------&quot; + test.getLong()); } } ThreadLocal的应用场景# 数据库连接 public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); } ThreadLocal的应用场景# Session管理 public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } ThreadLocal的应用场景# 多线程 * 描述 Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。 * 因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码， * 它们也无法访问到对方的ThreadLocal变量。 */ public class ThreadLocalExsample { /** * 创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run()方法， * 并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并且调用的set()方法被同步了， * 则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是一个ThreadLocal对象， * 因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同的值。 */ public static class MyRunnable implements Runnable { /** * 例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。 * 虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的 * set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值， * 他们仍然无法访问到对方的值。 */ private ThreadLocal threadLocal = new ThreadLocal(); @Override public void run() { //一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值 threadLocal.set((int) (Math.random() * 100D)); try { Thread.sleep(2000); } catch (InterruptedException e) { } //可以通过下面方法读取保存在ThreadLocal变量中的值 System.out.println(&quot;-------threadLocal value-------&quot;+threadLocal.get()); } } public static void main(String[] args) { MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); } } 运行结果 -------threadLocal value-------38 -------threadLocal value-------88 得出结论 ThreadLocal 中 set 和 get 操作的都是对应线程的 table数组，因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。 总结 在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； 在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。 ***转载评论：*** 阿拉斯丁_a9d8 public 【long】 getLong() { return longLocal.get(); } 把long的位置改成Long，就不会报空指针异常了。这个空指针异常和ThreadLocal没关系。 WaterYuan 在进行get之前，不比先set，不会空指针异常，只不过get得到null而已 ``` public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue(); } ``` ","link":"https://esinew.github.io/post/bean-you-hua-ji-threadlocal/"},{"title":"为什么要用spring bean？","content":"为什么要用spring bean？ [TOC] 什么是bean? EJB是Enterprise Java Bean的缩写，一个Bean扮演着应用程序素材的角色。它包含有一个functional interface，一个life-cycle interface，以及一个实做它所支援的商业方法的类别。对于程序员来说，最好的一点就是JavaBean可以实现代码的重复利用，另外对于程序的易维护性等等也有很重大的意义。 在Java模型中，通过Java Bean可以无限扩充Java程序的功能，通过JavaBean的组合可以快速的生成新的应用程序。 比如说一个购物车程序，要实现购物车中添加一件商品这样的功能，就可以写一个购物车操作的JavaBean，建立一个public的AddItem成员方法，前台Jsp文件里面直接调用这个方法来实现。如果后来又考虑添加商品的时候需要判断库存是否有货物，没有货物不得购买，在这个时候我们就可以直接修改JavaBean的AddItem方法，加入处理语句来实现，这样就完全不用修改前台jsp程序了。 Spring中的Bean到底都有哪些用法？ @Bean 基础声明 Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。 SpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。 快速搭建一个maven项目并配置好所需要的Spring 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在src根目录下创建一个AppConfig的配置类，这个配置类也就是管理一个或多个bean 的配置类，并在其内部声明一个myBean的bean，并创建其对应的实体类 @Configuration public class AppConfig { // 使用@Bean 注解表明myBean需要交给Spring进行管理 // 未指定bean 的名称，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式 @Bean public MyBean myBean(){ return new MyBean(); } } public class MyBean { public MyBean(){ System.out.println(&quot;MyBean Initializing&quot;); } } 在对应的test文件夹下创建一个测试类SpringBeanApplicationTests，测试上述代码的正确性 public class SpringBeanApplicationTests { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); context.getBean(&quot;myBean&quot;); } } 输出 : MyBean Initializing 随着SpringBoot的流行，我们现在更多采用基于注解式的配置从而替换掉了基于XML的配置，所以本篇文章我们主要探讨基于注解的@Bean以及和其他注解的使用。 @Bean 基本构成及其使用 在简单介绍了一下如何声明一个Bean组件，并将其交给Spring进行管理之后，下面我们来介绍一下Spring 的基本构成 @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Bean { @AliasFor(&quot;name&quot;) String[] value() default {}; @AliasFor(&quot;value&quot;) String[] name() default {}; Autowire autowire() default Autowire.NO; String initMethod() default &quot;&quot;; String destroyMethod() default AbstractBeanDefinition.INFER_METHOD; } @Bean不仅可以作用在方法上，也可以作用在注解类型上，在运行时提供注册。 value： name属性的别名，在不需要其他属性时使用，也就是说value 就是默认值 name： 此bean 的名称，或多个名称，主要的bean的名称加别名。如果未指定，则bean的名称是带注解方法的名称。如果指定了，方法的名称就会忽略，如果没有其他属性声明的话，bean的名称和别名可能通过value属性配置 autowire ： 此注解的方法表示自动装配的类型，返回一个Autowire类型的枚举，我们来看一下Autowire枚举类型的概念 // 枚举确定自动装配状态：即，bean是否应该使用setter注入由Spring容器自动注入其依赖项。 // 这是Spring DI的核心概念 public enum Autowire { // 常量，表示根本没有自动装配。 NO(AutowireCapableBeanFactory.AUTOWIRE_NO), // 常量，通过名称进行自动装配 BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME), // 常量，通过类型进行自动装配 BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE); private final int value; Autowire(int value) { this.value = value; } public int value() { return this.value; } public boolean isAutowire() { return (this == BY_NAME || this == BY_TYPE); } } autowire的默认值为No，默认表示不通过自动装配。 initMethod: 这个可选择的方法在bean实例化的时候调用，InitializationBean接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，InitializationBean 接口有一个定义好的初始化方法 void afterPropertiesSet() throws Exception; Spring不推荐使用InitializationBean 来调用其初始化方法，因为它不必要地将代码耦合到Spring。Spring推荐使用@PostConstruct注解或者为POJO类指定其初始化方法这两种方式来完成初始化。 不推荐使用： public class InitBean implements InitializingBean { public void afterPropertiesSet() {} } destroyMethod: 方法的可选择名称在调用bean示例在关闭上下文的时候，例如JDBC的close()方法，或者SqlSession的close()方法。DisposableBean 接口的实现允许在bean销毁的时候进行回调调用，DisposableBean 接口之后一个单个的方法 void destroy() throws Exception; Spring不推荐使用DisposableBean 的方式来初始化其方法，因为它会将不必要的代码耦合到Spring。作为替代性的建议，Spring 推荐使用@PreDestory注解或者为@Bean注解提供 destroyMethod 属性， 不推荐使用： public class DestroyBean { public void cleanup() {} } 推荐使用： public class MyBean { public MyBean(){ System.out.println(&quot;MyBean Initializing&quot;); } public void init(){ System.out.println(&quot;Bean 初始化方法被调用&quot;); } public void destroy(){ System.out.println(&quot;Bean 销毁方法被调用&quot;); } } @Configuration public class AppConfig { // @Bean @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;) public MyBean myBean(){ return new MyBean(); } } 修改一下测试类，测试其初始化方法和销毁方法在何时会被调用 public class SpringBeanApplicationTests { public static void main(String[] args) { // ------------------------------ 测试一 ------------------------------ ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // context.getBean(&quot;myBean&quot;); // 变体 context.getBean(&quot;myBean&quot;); ((AnnotationConfigApplicationContext) context).destroy(); // ((AnnotationConfigApplicationContext) context).close(); } } 初始化方法在得到Bean的实例的时候就会被调用，销毁方法在容器销毁或者容器关闭的时候会被调用。 @Bean 注解与其他注解产生的火花 在上面的一个小节中我们了解到了@Bean注解的几个属性，但是对于@Bean注解的功能来讲这有点太看不起bean了，@Bean另外一个重要的功能是能够和其他注解产生化学反应，如果你还不了解这些注解的话，那么请继续往下读，你会有收获的 这一节我们主要探讨@profile,@scope,@lazy,@depends-on @primary等注解 @Profile 注解 @Profile的作用是把一些meta-data进行分类，分成Active和InActive这两种状态，然后你可以选择在active 和在Inactive这两种状态下配置bean，在Inactive状态通常的注解有一个！操作符，通常写为：@Profile(&quot;!p&quot;),这里的p是Profile的名字。 三种设置方式： 可以通过ConfigurableEnvironment.setActiveProfiles()以编程的方式激活 可以通过AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME (spring.profiles.active )属性设置为 JVM属性 作为环境变量，或作为web.xml 应用程序的Servlet 上下文参数。也可以通过@ActiveProfiles 注解在集成测试中以声明方式激活配置文件。 作用域 作为类级别的注释在任意类或者直接与@Component 进行关联，包括@Configuration 类 作为原注解，可以自定义注解 作为方法的注解作用在任何方法 注意: ​ 如果一个配置类使用了Profile 标签或者@Profile 作用在任何类中都必须进行启用才会生效，如果@Profile({&quot;p1&quot;,&quot;!p2&quot;}) 标识两个属性，那么p1 是启用状态 而p2 是非启用状态的。 现有一个POJO类为Subject学科类，里面有两个属性，一个是like(理科)属性，一个是wenke(文科)属性，分别有两个配置类，一个是AppConfigWithActiveProfile ，一个是AppConfigWithInactiveProfile，当系统环境是 &quot;like&quot;的时候就注册 AppConfigWithActiveProfile ，如果是 &quot;wenke&quot;，就注册 AppConfigWithInactiveProfile，来看一下这个需求如何实现 Subject.java // 学科 public class Subject { // 理科 private String like; // 文科 private String wenke; get and set ... @Override public String toString() { return &quot;Subject{&quot; + &quot;like='&quot; + like + '\\'' + &quot;, wenke='&quot; + wenke + '\\'' + '}'; } } AppConfigWithActiveProfile.java 注册Profile 为like 的时候 @Profile(&quot;like&quot;) @Configuration public class AppConfigWithActiveProfile { @Bean public Subject subject(){ Subject subject = new Subject(); subject.setLike(&quot;物理&quot;); return subject; } } AppConfigWithInactiveProfile.java 注册Profile 为wenke 的时候 @Profile(&quot;wenke&quot;) @Configuration public class AppConfigWithInactiveProfile { @Bean public Subject subject(){ Subject subject = new Subject(); subject.setWenke(&quot;历史&quot;); return subject; } } 修改一下对应的测试类，设置系统环境，当Profile 为like 和 wenke 的时候分别注册各自对应的属性 // ------------------------------ 测试 profile ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 激活 like 的profile context.getEnvironment().setActiveProfiles(&quot;like&quot;); context.register(AppConfigWithActiveProfile.class,AppConfigWithInactiveProfile.class); context.refresh(); Subject subject = (Subject) context.getBean(&quot;subject&quot;); System.out.println(&quot;subject = &quot; + subject); 把context.getEnvironment().setActiveProfiles(&quot;wenke&quot;) 设置为wenke，观察其对应的输出内容发生了变化，这就是@Profile的作用，有一层可选择性注册的意味。 @Scope 注解 在Spring中对于bean的默认处理都是单例的，我们通过上下文容器.getBean方法拿到bean容器，并对其进行实例化，这个实例化的过程其实只进行一次，即多次getBean 获取的对象都是同一个对象，也就相当于这个bean的实例在IOC容器中是public的，对于所有的bean请求来讲都可以共享此bean。 那么假如我不想把这个bean被所有的请求共享或者说每次调用我都想让它生成一个bean实例该怎么处理呢？ 多例Bean bean的非单例原型范围会使每次发出对该特定bean的请求时都创建新的bean实例，也就是说，bean被注入另一个bean，或者通过对容器的getBean()方法调用来请求它，可以用如下图来表示： 通过一个示例来说明bean的多个实例 新建一个AppConfigWithAliasAndScope配置类，用来定义多例的bean， @Configuration public class AppConfigWithAliasAndScope { /** * 为myBean起两个名字，b1 和 b2 * @Scope 默认为 singleton，但是可以指定其作用域 * prototype 是多例的，即每一次调用都会生成一个新的实例。 */ @Bean({&quot;b1&quot;,&quot;b2&quot;}) @Scope(&quot;prototype&quot;) public MyBean myBean(){ return new MyBean(); } } 测试一下多例的情况： // ------------------------------ 测试scope ------------------------------ ApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithAliasAndScope.class); MyBean myBean = (MyBean) context.getBean(&quot;b1&quot;); MyBean myBean2 = (MyBean) context.getBean(&quot;b2&quot;); System.out.println(myBean); System.out.println(myBean2); 其他情况 除了多例的情况下，Spring还为我们定义了其他情况： Scope Descriptionn singleton 默认单例的bean定义信息，对于每个IOC容器来说都是单例对象 prototype bean对象的定义为任意数量的对象实例 request bean对象的定义为一次HTTP请求的生命周期，也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。仅仅在web-aware的上下文中有效 session bean对象的定义为一次HTTP会话的生命周期。仅仅在web-aware的上下文中有效 application bean对象的定义范围在ServletContext生命周期内。仅仅在web-aware的上下文中有效 websocket bean对象的定义为WebSocket的生命周期内。仅仅在web-aware的上下文中有效 singleton和prototype 一般都用在普通的Java项目中，而request、session、application、websocket都用于web应用中。 request、session、application、websocket的作用范围 你可以体会到 request、session、application、websocket 的作用范围在当你使用web-aware的ApplicationContext应用程序上下文的时候，比如XmlWebApplicationContext的实现类。如果你使用了像是ClassPathXmlApplicationContext的上下文环境时，就会抛出IllegalStateException因为Spring不认识这个作用范围。 @Lazy 注解 @Lazy : 表明一个bean 是否延迟加载，可以作用在方法上，表示这个方法被延迟加载；可以作用在@Component (或者由@Component 作为原注解) 注释的类上，表明这个类中所有的bean 都被延迟加载。如果没有@Lazy注释，或者@Lazy 被设置为false，那么该bean 就会急切渴望被加载；除了上面两种作用域，@Lazy 还可以作用在@Autowired和@Inject注释的属性上，在这种情况下，它将为该字段创建一个惰性代理，作为使用ObjectFactory或Provider的默认方法。下面来演示一下： @Lazy @Configuration @ComponentScan(basePackages = &quot;com.spring.configuration.pojo&quot;) public class AppConfigWithLazy { @Bean public MyBean myBean(){ System.out.println(&quot;myBean Initialized&quot;); return new MyBean(); } @Bean public MyBean IfLazyInit(){ System.out.println(&quot;initialized&quot;); return new MyBean(); } } 修改测试类 public class SpringConfigurationApplication { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithLazy.class); // 获取启动过程中的bean 定义的名称 for(String str : context.getBeanDefinitionNames()){ System.out.println(&quot;str = &quot; + str); } } } 输出你会发现没有关于bean的定义信息，但是当把@Lazy 注释拿掉，你会发现输出了关于bean的初始化信息 @DependsOn 注解 指当前bean所依赖的bean。任何指定的bean都能保证在此bean创建之前由IOC容器创建。在bean没有通过属性或构造函数参数显式依赖于另一个bean的情况下很少使用，可能直接使用在任何直接或者间接使用 Component 或者Bean 注解表明的类上。来看一下具体的用法 新建三个Bean，分别是FirstBean、SecondBean、ThirdBean三个普通的bean，新建AppConfigWithDependsOn并配置它们之间的依赖关系 public class FirstBean { @Autowired private SecondBean secondBean; @Autowired private ThirdBean thirdBean; public FirstBean() { System.out.println(&quot;FirstBean Initialized via Constuctor&quot;); } } public class SecondBean { public SecondBean() { System.out.println(&quot;SecondBean Initialized via Constuctor&quot;); } } public class ThirdBean { public ThirdBean() { System.out.println(&quot;ThirdBean Initialized via Constuctor&quot;); } } @Configuration public class AppConfigWithDependsOn { @Bean(&quot;firstBean&quot;) @DependsOn(value = { &quot;secondBean&quot;, &quot;thirdBean&quot; }) public FirstBean firstBean() { return new FirstBean(); } @Bean(&quot;secondBean&quot;) public SecondBean secondBean() { return new SecondBean(); } @Bean(&quot;thirdBean&quot;) public ThirdBean thirdBean() { return new ThirdBean(); } } 使用测试类进行测试，如下 // ------------------------------ 测试 DependsOn ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithDependsOn.class); context.getBean(FirstBean.class); context.close(); 输出 : SecondBean Initialized via Constuctor ThirdBean Initialized via Constuctor FirstBean Initialized via Constuctor 由于firstBean 的创建过程首先需要依赖secondBean 和 thirdBean的创建，所以secondBean 首先被加载其次是thirdBean 最后是firstBean。 如果把@DependsOn 注解加在AppConfigWithDependsOn 类上则它们的初始化顺序就会变为 firstBean、secondBean、thirdBean @Primary 注解 指示当多个候选者有资格自动装配依赖项时，应优先考虑bean。此注解在语义上就等同于在Spring XML中定义的bean 元素的primary属性。注意： 除非使用component-scanning进行组件扫描，否则在类级别上使用@Primary不会有作用。如果@Primary 注解定义在XML中，那么@Primary 的注解元注解就会忽略，相反使用 @Primary 的两种使用方式 与@Bean 一起使用，定义在方法上，方法级别的注解 与@Component 一起使用，定义在类上，类级别的注解 通过一则示例来演示一下： 新建一个AppConfigWithPrimary类，在方法级别上定义@Primary注解 @Configuration public class AppConfigWithPrimary { @Bean public MyBean myBeanOne(){ return new MyBean(); } @Bean @Primary public MyBean myBeanTwo(){ return new MyBean(); } } 上面代码定义了两个bean ，其中myBeanTwo 由@Primary 进行标注，表示它首先会进行注册，使用测试类进行测试 // ------------------------------ 测试 Primary ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithPrimary.class); MyBean bean = context.getBean(MyBean.class); System.out.println(bean); 你可以尝试放开@Primary ，使用测试类测试的话会发现出现报错信息，因为你尝试获取的是MyBean.class,而我们代码中定义了两个MyBean 的类型，所以需要@Primary 注解表明哪一个bean需要优先被获取。 ","link":"https://esinew.github.io/post/wei-shi-me-yao-yong-spring-bean/"}]}