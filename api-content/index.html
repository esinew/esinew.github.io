{"posts":[{"title":"mysql事务隔离级别及MVCC","content":"MySQL定义了4类隔离级别，包括一些具体规则，用来限定事物内外的哪些改变时可见的，哪些改变时不可见的，低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 第一类： Read Uncommitted(读取未提交的内容)事务A/事务B 在该隔离级别，所有事物都可以看到其他未提交事务的执行结果，本隔离级别很少用于实际应用，因为他的性能页不比其他级别好多少，读取未提交的数据，也被称之为脏读（Dirty Read）。 第二类： Read Committed(读取提交内容) 这是大多数数据库系统的默认隔离级别（但不是mysql默认的），他满足了隔离的简单定义：一个事物在提交之前对其他事物是不可见的，这种隔离级别也支持所谓的不可重复读取（Nonerepeatable Read）,因为同一事务的其他实例在该实例处理其他期间可能会有新的commit，所以同一select可能返回不同结果。 第三类： Repeatable Read(可复读) 这是mysql默认的隔离级别，他确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，不过理论上，这会导致另一个棘手的问题，幻读（Phantom Read），简单的说，幻读指当用户读取某一范围的数据行时，另一个事物又在该范围内插入了新行，当用户再读取该范围内的数据时，会发现有新的&quot;幻影&quot;行，Innodb和Falcon存储引擎通过多版本并发控制（MVCC）机制解决了该问题。 第四类： Serializerable(可串行化) 这是最高的隔离级别，他通过强制事物排序，使之不可能相互冲突，从而解决了幻读问题，简言之，它是在每个读的数据行上加共享锁，在这个级别，可能导致大量的超时现象和锁竞争。 脏读： 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务RollBack了操作，则后面的事物所读去的数据就是不正确的。 幻读： 在一个事务的两次查询中数据不一致，例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的数据，先前的事务在接下来的查询中，就会发现有几列数据是他先前所没有的。（数据条数不同） 不可重复读： 在一个事物的两次查询中数据不一致，这可能是两次查询过程中间插入了一个事物更新的原有的数据。（同一条数据） 以上四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。 隔离级别 脏读 不可重复读 幻读读取未提交内容 v v v读取已提交内容 x v v 可重复读 x x v 可串行化 x x x 修改MySQL隔离级别： sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf ![CSDN_1591409202681](https://esinew.github.io//post-images/15 修改完成后重启mysql，使其生效： sudo service mysql restart Django提供了一个API来控制数据库事务 atomic(using=None, savepoint=True) 原子性： 是由mysql的事物操作来界定的，atomic允许我们在执行代码块时，在数据库层面提供原子性保证，如果代码块成功完成，相应的变化会被提交到数据库进行commit，否则会进行rollback。 atomic可以嵌套，在下面的例子里，使用while语句，当一个内部块完成后，如果某个异常在外部块被抛出，内部块上的操作仍然可以回滚（前提是外部块也被atomic装饰过） atomic被用作装饰器 from django.db import transaction ***@transaction.atomic*** def viewfunc(request): do_stuff() 创建保存点 savepoint() 提交保存点 savepoint_commit() 回滚保存点 savepoint_rollback() 订单并发处理悲观锁乐观锁在冲突比较少的时候采用乐观锁，减少不需要加锁释放锁的开销，可以提高性能。 在冲突比较多的时候采用悲观锁，减少重复尝试次数，乐观锁重复操作的代价比较大。 MySQL的MVCC及实现原理 首先声明，MySQL的测试环境是5.7 前提概要 什么是MVCC? MVCCMVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 什么是当前读和快照读？ 在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读? 当前读像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读， 为什么叫当前读？ 就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁快照读像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现当前读，快照读和MVCC的关系准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。 而相对而言，当前读就是悲观锁的具体功能实现，要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理 MVCC能解决什么问题，好处是？ 数据库并发场景有三种，分别为： 读-读：不存在任何问题，也不需要并发控制 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读， 幻读，不可重复读写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失 MVCC带来的好处是？ 多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题小结一下总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题而提出的解决方案，所以在数据库中有了MVCC，所以我们可以形成两个组合： MVCC + 悲观锁MVCC解决读写冲突，悲观锁解决写写冲突 MVCC + 乐观锁MVCC解决读写冲突，乐观锁解决写写冲突 这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题*MYSQL 事务日志* 事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。 MySQL Innodb中跟数据持久性、一致性有关的日志，有以下几种： **1.**Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的Redo Log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。 **2.**Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC MVCC的实现原理 MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念隐式字段每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段 DB_TRX_ID 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务IDDB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了 如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本undo日志 undo log主要分为两种： insert undo log代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃 update undo log事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除purge 从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见即当前记录没有相关活跃事务在操作时，那么这条记录一定是可以被安全清除的。对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下： 一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL 二、 现在来了一个事务1对该记录的name做出了修改，改为Tom在事务1修改该行(记录)数据时，数据库会先对该行加排他锁然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它事务提交后，释放锁 三、 又来了个事务2修改person表的同一个记录，将age修改为30岁在事务2修改该行数据时，数据库也先为该行加锁然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录事务提交，释放锁 从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）Read View(读视图) 什么是Read View? 什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。 Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本那么这个判断条件是什么呢？ 如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性。 trx_list（名字我随便取的）一个数值列表，用来维护Read View生成时刻系统正活跃的事务IDup_limit_id记录trx_list列表中事务ID最小的IDlow_limit_idReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1，首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断。接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的。 整体流程 我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了整体的流程是怎么样的呢？我们可以模拟一下： 当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list。 事务1事务2事务3事务4事务开始事务开始事务开始事务开始………修改且已提交进行中快照读进行中……… Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者 ) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图： 我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。 所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。 也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。 MVCC相关问题 RR是如何在RC级的基础上解决不可重复读的？ 当前读和快照读在RR级别下的区别： 表1:事务A事务B开启事务开启事务快照读(无影响)查询金额为500快照读查询金额为500更新金额为400提交事务select 快照读金额为500select lock in share mode当前读金额为400在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400。 表2:事务A事务B开启事务开启事务快照读（无影响）查询金额为500更新金额为400提交事务select 快照读金额为400select lock in share mode当前读金额为400。 而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力，我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的。 RC,RR级别下的InnoDB快照读有什么不同？ 正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见。而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。 MVCC原理： MVCC（ Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。 READ COMMITTD、 REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同， READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。 ","link":"https://esinew.github.io/post/mysql-shi-wu-ge-chi-ji-bie-ji-mvcc/"},{"title":"MySQL数据库（一）","content":"mysql默认的存储引擎：InnoDB InnoDB(其行锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制) MyISAM表最适合大量的数据读而少量数据更新的混合操作，或者使用压缩的只读表。 MEMORY存储引擎适合存储非永久需要的数据，或者能够从基于磁盘的表中重新生成的数据。 特点：性能强，每次查询具有原子性执行速度快于InnoDB; ACID特性 原子性（Atomicity）：要么一起成功，要么一起失败 一致性（Consistency）：数据不能在结束操作后状态不一样了 隔离性（Isolation）：事务与事务不相互影响 持久性（Durability）：数据能被长久的保存 四个隔离级别 读未提交 读已提交（多数SQL默认级别） 可重复读（MySQL默认级别）(MVCC) 序列化（串行化） CAP定理和BASE理论 CAP：web服务无法同时满足三个属性——一致性、可用性、分区容错性 BASE:CAP的扩充，基本可用（保大）、软状态（不在意中间过程）、最终一致性（认定目标） 数据库锁和并发策略 表锁：读锁、写锁（开销小、加锁快，不会出现死锁、粒度大、易发生锁冲突） 行锁：共享锁、排他锁（Update、Delet、insert）（select无锁）（开销大、易死锁、粒度最小、不易发生锁冲突） ​ 共享锁：允许一个事务读取一行，阻止其他事务获得相同数据集的共享锁与排他锁。（显示加 锁：select * from table where...for update） ​ innoDB 的行锁实现方式是基于索引项的。（即使尝试获取不同行的排他锁，若使用了相同的 索引键，也可能造成锁冲突。） 页级锁：粒度介于行锁和表锁之间，性能折中 并发策略 乐观锁： 悲观锁： 减少锁表的概率 ​ 减少 insert 、update 、delete 语句执行到 commite 之间的时间。具体点批量执行改为单个执 行、优化 sql 自身的非执行速度  如果异常对事物进行回滚 登陆系统，做一个主表，一个分表，分表写入不加索引，主表读添加索引（索引是添加B+树（非聚簇——&gt;聚簇）插入费时（维护B+树），读快），最后分表同步到主表上。 存储过程优化思路： 1. 尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。 2. 中间结果存放于临时表，加索引。 3. 少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如 对一个 100 万行 的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次 读取。 4. 事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成 并发操作的阻塞， 死锁。导致查询极慢，cpu 占用率极地。 5. 使用 try-catch 处理错误异常。 6. 查找语句尽量不要放在循环内。 第一范式：有主键，具有原子性，字段不可分割 第二范式：完全依赖，表中非主键列不存在对主键的部分依赖。要求每个表只描述一 件事情。 第三范式：没有传递依赖，表中的列不存在对非主键列的传递依赖。 数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户 需求 7.2 数据库命令规范  所有数据库对象名称必须使用小写字母并用下划线分割  所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）  数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符  临时库表必须以 tmp 为前缀并以日期为后缀，备份表必须以 bak 为前缀并以日期 (时间戳) 为后缀  所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据 类型隐式转换，会造成列上的索引失效，导致查询效率降低） ","link":"https://esinew.github.io/post/mysql-shu-ju-ku-yi/"},{"title":"@bean优化及ThreadLocal","content":"[TOC] @Bean注解（及优化方案） 银行开户的场景。 银行需要将用户的信用等级，使用记录信息发送给用户。 接口分析 1:查询信用等级接口 2:查询使用记录的接口 3:发送邮件(需配置smtp) 要求 各个接口相互独立，任意一个接口的实现被新文件替换，都不能影响其他接口的使用。 一： 传统的编程方式 1: 实现各个接口 2: 将接口组织在一起组成服务 Spring 创建bean的时机 默认在启动spring容器的时候，spring容器配置文件中的类就已经创建完成对象了 在中添加属性lazy-init，默认值为false。 ​ true 在context.getBean的时候才要创建对象 ​ * 优点 ​ 如果该bean中有大数据存在，则什么时候context.getBean,什么时候创建对象 ​ 可以防止数据过早的停留在内存中，做到了懒加载 ​ * 缺点 ​ 如果spring配置文件中，该bean的配置有错误，那么在tomcat容器启动的时候，发现不了 ​ false 在启动spring容器的时候创建对象 ​ * 优点 ​ 如果在启动tomcat时要启动spring容器， ​ 那么如果spring容器会错误，这个时候tomcat容器不会正常启动 ​ * 缺点 ​ 如果存在大量的数据，会过早的停留在内存中 Spring Bean的作用域（bean的作用域不同，需要进行选择及优化） 在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。 目前Spring Bean的作用域或者说范围主要有五种。 （1）被声明为singletton的bean 如果bean的作用域的属性被声明为singleton，那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。 Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，singleton作用域是Spring中的缺省作用域。你可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示： &lt;!-- A bean definition with singleton scope --&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; 单例的例子 1.首先创建一个bean。 package com.spring.demo; public class SingletonBean{ private String message; public void setMessage(String message){ this.message = message; } public void getMessage(){ System.out.println(&quot;Your Message : &quot; + message); } } 2.在Spring的配置文件中配置该bean。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; &lt;!-- 或者 --&gt; &lt;!-- &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; &gt;&lt;/bean&gt; --&gt; &lt;/beans&gt; 测试该Bean是否为单例的。 package com.spring.demo; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.junit.Test; public class TestBean { @Test public void textUser() { //1.获取spring文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean.xml&quot;); //2.由配置文件返回对象 SingletonBean singletonBeanA = (SingletonBean)context.getBean(&quot;SingletonBean&quot;); singletonBeanA.setMessage(&quot;I'm object A&quot;); singletonBeanA.getMessage(); SingletonBean singletonBeanB = (SingletonBean)context.getBean(&quot;SingletonBean&quot;); singletonBeanB.getMessage(); } } 运行结果： （2）被声明为prototype的bean 当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。 prototype的例子。 还是上面的代码。其他代码不变，把Bean.xml文件中bean的作用域由singleton改为prototype。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;SingletonBean&quot; class=&quot;com.spring.demo.SingletonBean&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 执行代码，程序的执行结果为： 从图上可以看出在SingletonBeanA中设置的参数值在SingletonBeanB就获取不到了，说明这两个对象现在返回的就不是同一个对象实例。 （3）使用注解定义bean的作用域 除了在Bean.xml文件中定义bean的作用域之外，还可以使用注解来定义 bean 的作用域。 1.在Bean中加上注解。 package com.spring.demo; import org.springframework.context.annotation.Scope;; import org.springframework.stereotype.Component; @Component(&quot;SingletonBean&quot;) @Scope(&quot;prototype&quot;) public class SingletonBean { private String message; public void setMessage(String message){ this.message = message; } public void getMessage(){ System.out.println(&quot;Your Message : &quot; + message); } } @Component(&quot;SingletonBean&quot;)注解是告诉Spring这是一个bean。 @Scope(&quot;prototype&quot;) 注解是告诉Spring该bean的作用域是prototype。 2.bean.xml文件修改一下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt; &lt;/beans&gt; &lt;context:component-scan base-package=&quot;com.spring.demo&quot; /&gt;就是扫描com.spring.demo包中的所有类的注解。 测试代码不用变，运行测试。 和在bean.xml中直接定义bean和其作用域是一样的效果。其他作用域也可以使用注解方式声明bean的作用域。 request,session和application这三个作用域都是基于web的Spring WebApplicationContext实现的，只有在web环境下（比如XmlWebApplicationContext）中才能使用。 如果开发者仅仅在常规的Spring IoC容器中比如ClassPathXmlApplicationContext在中使用这些作用域，那么将会抛出一个IllegalStateException来说明使用了未知的作用域。 也就是当用户使用Spring的WebApplicationContext时，除了使用常规的singleton和prototype作用域之外，还可以使用另外3种Bean的作用域，即request,session和application。 在使用Web应用环境相关的Bean作用域时，必须在Web容器中进行一些额外的配置： 1.如果开发者使用了Spring Web MVC框架的话，每一个请求都会通过Spring的DispatcherServlet来处理，也就没有其他特殊的初始化配置，就不需要配置了。DispatcherServlet已经包含了相关的状态。 2.如果开发者使用的是低版本Web容器比如Servlet 2.5的web容器，请求不是通过Spring的DispatcherServlet（比如JSF或者Struts）来处理的。那么开发者需要注册org.springframework.web.context.request.RequestContextListener或者ServletRequestListener。可以在web.xml中增加如下的Listener声明： &lt;web-app&gt; ... &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; ... &lt;/web-app&gt; ServletContextListener只负责监听web容器启动和关闭的事件，而RequestContextListener实现了ServletRequestListener监听器接口，该监听器监听http请求事件。Web服务器接收到的每一次请求都会通知该监听器。 而在Servlet 3.0以后，这些都能够通过WebApplicationInitializer接口来实现配置。 3.如果不使用Listener，也可以考虑使用Spring的RequestContextFilter，通过http过滤器进行配置，在url-pattern中对所有的页面进行过滤。也是在web.xml中进行配置。 &lt;web-app&gt; ... &lt;filter&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; ... &lt;/web-app&gt; 配置完这些额外的配置之后，就可以使用另外的3种bean的作用域了。 （4）请求作用域 请求作用域参考如下的Bean定义 &lt;bean id=&quot;loginAction&quot; class=&quot;com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt; Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。 当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。 （5）会话作用域 会话作用域参考如下的Bean定义 &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。 Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。 （6）全局作用域 全局作用域参考如下的Bean定义 &lt;bean id=&quot;appPreferences&quot; class=&quot;com.foo.AppPreferences&quot; scope=&quot;application&quot;/&gt; Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处： 1.application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。 2.application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。 接下来再来简单的学习下在Spring当中如何自定义作用域： 在Spring 2.0中，Spring的Bean作用域机制是可以扩展的，这意味着，你不仅可以使用Spring提供的预定义Bean作用域，还可以定义自己的作用域，甚至重新定义现有的作用域（不提倡这么做，而且你不能覆盖内置的singleton和prototype作用域） （7）自定义作用域 除了使用Spring已经定义好的作用域之外，还可以自定义bean的作用域。 要底线自定义作用域 1.首先需要实现自定义Scope类。 首先要先实现org.springframework.beans.factory.config.Scope这个接口，要将自定义scope集成到Spring容器当中就必须要实现这个接口。接口中有两个常用的方法，分别用于底层存储机制获取和删除这个对象。 2.在实现一个或多个自定义Scope并测试通过之后，接下来便是如何让Spring容器来识别新的作用域。registerScope方法就是在Spring容器中用来注册新的作用域。 void registerScope(String scopeName, Scope scope); 其中：第一个参数是与作用域相关的全局唯一的名称，第二个参数是准备实现的作用域的实例，就是实现Scope接口的实例。 比如实现Scope接口的类为SimpleThreadScope，要实现的自定义的bean的作用域的名称为“thread”,那就可以这么写 Scope threadScope = new SimpleThreadScope(); beanFactory.registerScope(&quot;thread&quot;, threadScope); 3.在实现和注册自定义的scope类之后，就可以通过如下类似的Bean定义来使用自定义的Scope: &lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;thread&quot;&gt; 另外，在自定义的Scope中，开发者也不限于仅仅通过编程方式来实现自定义的bean的作用域，也可以在Spring的配置文件中配置和使用自定义作用域和，比如配置CustomScopeConfigurer实例实现自定义的作用域，声明作用域名称为“thread”，就可以在xml文件中做如下类似的定义。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt; &lt;property name=&quot;scopes&quot;&gt; &lt;map&gt; &lt;entry key=&quot;thread&quot;&gt; &lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;bar&quot; class=&quot;x.y.Bar&quot; scope=&quot;thread&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Rick&quot;/&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt; &lt;property name=&quot;bar&quot; ref=&quot;bar&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; Spring的并发问题——有状态Bean和无状态Bean 一、有状态和无状态 有状态会话bean ：每个用户有自己特有的一个实例，在用户的生存期内，bean保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean的生命期也告结束。即每个用户最初都会得到一个初始的bean。简单来说，有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。 无状态会话bean ：bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。简单来说，无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。 一个有状态的bean 二、解决有状态bean的线程安全问题 Spring对bean的配置中有四种配置方式，我们只说其中两种：singleton单例模式、prototype原型模式。 默认的配置是singleton。 singleton表示该bean全局只有一个实例。 prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的Bean。 如果对有状态的bean使用了singleton的话会出现线程安全问题。 例如上面的例子 如果有两个用户同时访问 假定为user1,user2 当user1 调用到程序中的1步骤的时候，该Bean的私有变量user被付值为user1 当user1的程序走到2步骤的时候，该Bean的私有变量user被重新付值为user1_create 理想的状况，当user1走到3步骤的时候，私有变量user应该为user1_create; 但如果在user1调用到3步骤之前，user2开始运行到了1步骤了，由于单态的资源共享，则私有变量user被修改为user2 这种情况下，user1的步骤3用到的user.getId()实际用到是user2的对象。 对于这种情况我们可以这样解决 1.将有状态的bean配置成prototype模式，让每一个线程都创建一个prototype实例。但是这样会产生很多的实例消耗较多的内存空间。 2.使用ThreadLocal变量，为每一条线程设置变量副本。 使用ThreadLocal的例子： 例如，我们有一个银行的BankDAO类和一个个人账户的PeopleDAO类，现在需要个人向银行进行转账，在PeopleDAO类中有一个账户减少的方法，BankDAO类中有一个账户增加的方法，那么这两个方法在调用的时候必须使用同一个Connection数据库连接对象，如果他们使用两个Connection对象，则会开启两段事务，可能出现个人账户减少而银行账户未增加的现象。使用同一个Connection对象的话，在应用程序中可能会设置为一个全局的数据库连接对象，从而避免在调用每个方法时都传递一个Connection对象。问题是当我们把Connection对象设置为全局变量时，你不能保证是否有其他线程会将这个Connection对象关闭，这样就会出现线程安全问题。解决办法就是在进行转账操作这个线程中，使用ThreadLocal中获取Connection对象，这样，在调用个人账户减少和银行账户增加的线程中，就能从ThreadLocal中取到同一个Connection对象，并且这个Connection对象为转账操作这个线程独有，不会被其他线程影响，保证了线程安全性。 ThreadLocal作用、场景、原理*（解决bean共享作用域资源占用及线程冲突问题）* 1.ThreadLocal 是什么？ 在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。 在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID) 1.1.ThreadLocal 的作用？ ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 2.Android源码中也可以看到ThreadLocal的身影 这里以andorid 源码的Handler为例子。看看Handker是怎么用ThreadLocal的。Handler就必须获取当前线程的 Looper 对象，而每一个线程的 Looper 是不一致的。因为每一个线程都会有一个 Looper 对象，因此使用 ThradLocal 去保存和获取当前线程的 Looper 就可以达到这个的效果。 2.1. Looper 内部的关于在 ThreadLocal 中存储 Looper 和 获取 Looper 的源码。 //Looper.prepare(); ​ private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } //将创建的 Looper 对象保存到 sThreadLocal 中。 sThreadLocal.set(new Looper(quitAllowed)); } ​ ​ //从 ThreadLocal 取出 Looper 对象 public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 3.ThreadLocal的内部原理 我们从源码中了解ThreadLocal的原理，下面来看一下具体ThreadLocal是如何实现的。 ThreadLocal类中提供了几个方法： 1.public T get() { } 2.public void set(T value) { } 3.public void remove() { } 4.protected T initialValue(){ } get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。 3.1.先看下get方法源码的实现 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread's value of this thread-local */ public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue(); } /** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */ private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } 第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是 this，而不是当前线程t。 如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。 看看getMap(t)做了些什么 * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。 那么我们继续取Thread类中取看一下成员变量threadLocals是什么?继续查看源码 * ThreadLocalMap is a customized hash map suitable only for * maintaining thread local values. No operations are exported * outside of the ThreadLocal class. The class is package private to * allow declaration of fields in class Thread. To help deal with * very large and long-lived usages, the hash table entries use * WeakReferences for keys. However, since reference queues are not * used, stale entries are guaranteed to be removed only when * the table starts running out of space. */ static class ThreadLocalMap { /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } //省略.... } 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现。 再看setInitialValue()方法 setInitialValue()很容易理解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现。 * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } 如果使用ThreadLocal时，先进行get之前，必须先set，否则会报空指针异常 public class ThreadLocalExsample { ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;&gt;(); public void set() { longLocal.set(Thread.currentThread().getId()); } public long getLong() { return longLocal.get(); } public static void main(String[] args) { ThreadLocalExsample test = new ThreadLocalExsample(); //注意:没有set之前，直接get，报null异常了 System.out.println(&quot;-------threadLocal value-------&quot; + test.getLong()); } } ThreadLocal的应用场景# 数据库连接 public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); } ThreadLocal的应用场景# Session管理 public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } ThreadLocal的应用场景# 多线程 * 描述 Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。 * 因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码， * 它们也无法访问到对方的ThreadLocal变量。 */ public class ThreadLocalExsample { /** * 创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run()方法， * 并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并且调用的set()方法被同步了， * 则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是一个ThreadLocal对象， * 因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同的值。 */ public static class MyRunnable implements Runnable { /** * 例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。 * 虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的 * set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值， * 他们仍然无法访问到对方的值。 */ private ThreadLocal threadLocal = new ThreadLocal(); @Override public void run() { //一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值 threadLocal.set((int) (Math.random() * 100D)); try { Thread.sleep(2000); } catch (InterruptedException e) { } //可以通过下面方法读取保存在ThreadLocal变量中的值 System.out.println(&quot;-------threadLocal value-------&quot;+threadLocal.get()); } } public static void main(String[] args) { MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); } } 运行结果 -------threadLocal value-------38 -------threadLocal value-------88 得出结论 ThreadLocal 中 set 和 get 操作的都是对应线程的 table数组，因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。 总结 在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； 在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。 ***转载评论：*** 阿拉斯丁_a9d8 public 【long】 getLong() { return longLocal.get(); } 把long的位置改成Long，就不会报空指针异常了。这个空指针异常和ThreadLocal没关系。 WaterYuan 在进行get之前，不比先set，不会空指针异常，只不过get得到null而已 ``` public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue(); } ``` ","link":"https://esinew.github.io/post/bean-you-hua-ji-threadlocal/"},{"title":"为什么要用spring bean？","content":"为什么要用spring bean？ [TOC] 什么是bean? EJB是Enterprise Java Bean的缩写，一个Bean扮演着应用程序素材的角色。它包含有一个functional interface，一个life-cycle interface，以及一个实做它所支援的商业方法的类别。对于程序员来说，最好的一点就是JavaBean可以实现代码的重复利用，另外对于程序的易维护性等等也有很重大的意义。 在Java模型中，通过Java Bean可以无限扩充Java程序的功能，通过JavaBean的组合可以快速的生成新的应用程序。 比如说一个购物车程序，要实现购物车中添加一件商品这样的功能，就可以写一个购物车操作的JavaBean，建立一个public的AddItem成员方法，前台Jsp文件里面直接调用这个方法来实现。如果后来又考虑添加商品的时候需要判断库存是否有货物，没有货物不得购买，在这个时候我们就可以直接修改JavaBean的AddItem方法，加入处理语句来实现，这样就完全不用修改前台jsp程序了。 Spring中的Bean到底都有哪些用法？ @Bean 基础声明 Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。 SpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。 快速搭建一个maven项目并配置好所需要的Spring 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在src根目录下创建一个AppConfig的配置类，这个配置类也就是管理一个或多个bean 的配置类，并在其内部声明一个myBean的bean，并创建其对应的实体类 @Configuration public class AppConfig { // 使用@Bean 注解表明myBean需要交给Spring进行管理 // 未指定bean 的名称，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式 @Bean public MyBean myBean(){ return new MyBean(); } } public class MyBean { public MyBean(){ System.out.println(&quot;MyBean Initializing&quot;); } } 在对应的test文件夹下创建一个测试类SpringBeanApplicationTests，测试上述代码的正确性 public class SpringBeanApplicationTests { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); context.getBean(&quot;myBean&quot;); } } 输出 : MyBean Initializing 随着SpringBoot的流行，我们现在更多采用基于注解式的配置从而替换掉了基于XML的配置，所以本篇文章我们主要探讨基于注解的@Bean以及和其他注解的使用。 @Bean 基本构成及其使用 在简单介绍了一下如何声明一个Bean组件，并将其交给Spring进行管理之后，下面我们来介绍一下Spring 的基本构成 @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Bean { @AliasFor(&quot;name&quot;) String[] value() default {}; @AliasFor(&quot;value&quot;) String[] name() default {}; Autowire autowire() default Autowire.NO; String initMethod() default &quot;&quot;; String destroyMethod() default AbstractBeanDefinition.INFER_METHOD; } @Bean不仅可以作用在方法上，也可以作用在注解类型上，在运行时提供注册。 value： name属性的别名，在不需要其他属性时使用，也就是说value 就是默认值 name： 此bean 的名称，或多个名称，主要的bean的名称加别名。如果未指定，则bean的名称是带注解方法的名称。如果指定了，方法的名称就会忽略，如果没有其他属性声明的话，bean的名称和别名可能通过value属性配置 autowire ： 此注解的方法表示自动装配的类型，返回一个Autowire类型的枚举，我们来看一下Autowire枚举类型的概念 // 枚举确定自动装配状态：即，bean是否应该使用setter注入由Spring容器自动注入其依赖项。 // 这是Spring DI的核心概念 public enum Autowire { // 常量，表示根本没有自动装配。 NO(AutowireCapableBeanFactory.AUTOWIRE_NO), // 常量，通过名称进行自动装配 BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME), // 常量，通过类型进行自动装配 BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE); private final int value; Autowire(int value) { this.value = value; } public int value() { return this.value; } public boolean isAutowire() { return (this == BY_NAME || this == BY_TYPE); } } autowire的默认值为No，默认表示不通过自动装配。 initMethod: 这个可选择的方法在bean实例化的时候调用，InitializationBean接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，InitializationBean 接口有一个定义好的初始化方法 void afterPropertiesSet() throws Exception; Spring不推荐使用InitializationBean 来调用其初始化方法，因为它不必要地将代码耦合到Spring。Spring推荐使用@PostConstruct注解或者为POJO类指定其初始化方法这两种方式来完成初始化。 不推荐使用： public class InitBean implements InitializingBean { public void afterPropertiesSet() {} } destroyMethod: 方法的可选择名称在调用bean示例在关闭上下文的时候，例如JDBC的close()方法，或者SqlSession的close()方法。DisposableBean 接口的实现允许在bean销毁的时候进行回调调用，DisposableBean 接口之后一个单个的方法 void destroy() throws Exception; Spring不推荐使用DisposableBean 的方式来初始化其方法，因为它会将不必要的代码耦合到Spring。作为替代性的建议，Spring 推荐使用@PreDestory注解或者为@Bean注解提供 destroyMethod 属性， 不推荐使用： public class DestroyBean { public void cleanup() {} } 推荐使用： public class MyBean { public MyBean(){ System.out.println(&quot;MyBean Initializing&quot;); } public void init(){ System.out.println(&quot;Bean 初始化方法被调用&quot;); } public void destroy(){ System.out.println(&quot;Bean 销毁方法被调用&quot;); } } @Configuration public class AppConfig { // @Bean @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;) public MyBean myBean(){ return new MyBean(); } } 修改一下测试类，测试其初始化方法和销毁方法在何时会被调用 public class SpringBeanApplicationTests { public static void main(String[] args) { // ------------------------------ 测试一 ------------------------------ ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // context.getBean(&quot;myBean&quot;); // 变体 context.getBean(&quot;myBean&quot;); ((AnnotationConfigApplicationContext) context).destroy(); // ((AnnotationConfigApplicationContext) context).close(); } } 初始化方法在得到Bean的实例的时候就会被调用，销毁方法在容器销毁或者容器关闭的时候会被调用。 @Bean 注解与其他注解产生的火花 在上面的一个小节中我们了解到了@Bean注解的几个属性，但是对于@Bean注解的功能来讲这有点太看不起bean了，@Bean另外一个重要的功能是能够和其他注解产生化学反应，如果你还不了解这些注解的话，那么请继续往下读，你会有收获的 这一节我们主要探讨@profile,@scope,@lazy,@depends-on @primary等注解 @Profile 注解 @Profile的作用是把一些meta-data进行分类，分成Active和InActive这两种状态，然后你可以选择在active 和在Inactive这两种状态下配置bean，在Inactive状态通常的注解有一个！操作符，通常写为：@Profile(&quot;!p&quot;),这里的p是Profile的名字。 三种设置方式： 可以通过ConfigurableEnvironment.setActiveProfiles()以编程的方式激活 可以通过AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME (spring.profiles.active )属性设置为 JVM属性 作为环境变量，或作为web.xml 应用程序的Servlet 上下文参数。也可以通过@ActiveProfiles 注解在集成测试中以声明方式激活配置文件。 作用域 作为类级别的注释在任意类或者直接与@Component 进行关联，包括@Configuration 类 作为原注解，可以自定义注解 作为方法的注解作用在任何方法 注意: ​ 如果一个配置类使用了Profile 标签或者@Profile 作用在任何类中都必须进行启用才会生效，如果@Profile({&quot;p1&quot;,&quot;!p2&quot;}) 标识两个属性，那么p1 是启用状态 而p2 是非启用状态的。 现有一个POJO类为Subject学科类，里面有两个属性，一个是like(理科)属性，一个是wenke(文科)属性，分别有两个配置类，一个是AppConfigWithActiveProfile ，一个是AppConfigWithInactiveProfile，当系统环境是 &quot;like&quot;的时候就注册 AppConfigWithActiveProfile ，如果是 &quot;wenke&quot;，就注册 AppConfigWithInactiveProfile，来看一下这个需求如何实现 Subject.java // 学科 public class Subject { // 理科 private String like; // 文科 private String wenke; get and set ... @Override public String toString() { return &quot;Subject{&quot; + &quot;like='&quot; + like + '\\'' + &quot;, wenke='&quot; + wenke + '\\'' + '}'; } } AppConfigWithActiveProfile.java 注册Profile 为like 的时候 @Profile(&quot;like&quot;) @Configuration public class AppConfigWithActiveProfile { @Bean public Subject subject(){ Subject subject = new Subject(); subject.setLike(&quot;物理&quot;); return subject; } } AppConfigWithInactiveProfile.java 注册Profile 为wenke 的时候 @Profile(&quot;wenke&quot;) @Configuration public class AppConfigWithInactiveProfile { @Bean public Subject subject(){ Subject subject = new Subject(); subject.setWenke(&quot;历史&quot;); return subject; } } 修改一下对应的测试类，设置系统环境，当Profile 为like 和 wenke 的时候分别注册各自对应的属性 // ------------------------------ 测试 profile ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 激活 like 的profile context.getEnvironment().setActiveProfiles(&quot;like&quot;); context.register(AppConfigWithActiveProfile.class,AppConfigWithInactiveProfile.class); context.refresh(); Subject subject = (Subject) context.getBean(&quot;subject&quot;); System.out.println(&quot;subject = &quot; + subject); 把context.getEnvironment().setActiveProfiles(&quot;wenke&quot;) 设置为wenke，观察其对应的输出内容发生了变化，这就是@Profile的作用，有一层可选择性注册的意味。 @Scope 注解 在Spring中对于bean的默认处理都是单例的，我们通过上下文容器.getBean方法拿到bean容器，并对其进行实例化，这个实例化的过程其实只进行一次，即多次getBean 获取的对象都是同一个对象，也就相当于这个bean的实例在IOC容器中是public的，对于所有的bean请求来讲都可以共享此bean。 那么假如我不想把这个bean被所有的请求共享或者说每次调用我都想让它生成一个bean实例该怎么处理呢？ 多例Bean bean的非单例原型范围会使每次发出对该特定bean的请求时都创建新的bean实例，也就是说，bean被注入另一个bean，或者通过对容器的getBean()方法调用来请求它，可以用如下图来表示： 通过一个示例来说明bean的多个实例 新建一个AppConfigWithAliasAndScope配置类，用来定义多例的bean， @Configuration public class AppConfigWithAliasAndScope { /** * 为myBean起两个名字，b1 和 b2 * @Scope 默认为 singleton，但是可以指定其作用域 * prototype 是多例的，即每一次调用都会生成一个新的实例。 */ @Bean({&quot;b1&quot;,&quot;b2&quot;}) @Scope(&quot;prototype&quot;) public MyBean myBean(){ return new MyBean(); } } 测试一下多例的情况： // ------------------------------ 测试scope ------------------------------ ApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithAliasAndScope.class); MyBean myBean = (MyBean) context.getBean(&quot;b1&quot;); MyBean myBean2 = (MyBean) context.getBean(&quot;b2&quot;); System.out.println(myBean); System.out.println(myBean2); 其他情况 除了多例的情况下，Spring还为我们定义了其他情况： Scope Descriptionn singleton 默认单例的bean定义信息，对于每个IOC容器来说都是单例对象 prototype bean对象的定义为任意数量的对象实例 request bean对象的定义为一次HTTP请求的生命周期，也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。仅仅在web-aware的上下文中有效 session bean对象的定义为一次HTTP会话的生命周期。仅仅在web-aware的上下文中有效 application bean对象的定义范围在ServletContext生命周期内。仅仅在web-aware的上下文中有效 websocket bean对象的定义为WebSocket的生命周期内。仅仅在web-aware的上下文中有效 singleton和prototype 一般都用在普通的Java项目中，而request、session、application、websocket都用于web应用中。 request、session、application、websocket的作用范围 你可以体会到 request、session、application、websocket 的作用范围在当你使用web-aware的ApplicationContext应用程序上下文的时候，比如XmlWebApplicationContext的实现类。如果你使用了像是ClassPathXmlApplicationContext的上下文环境时，就会抛出IllegalStateException因为Spring不认识这个作用范围。 @Lazy 注解 @Lazy : 表明一个bean 是否延迟加载，可以作用在方法上，表示这个方法被延迟加载；可以作用在@Component (或者由@Component 作为原注解) 注释的类上，表明这个类中所有的bean 都被延迟加载。如果没有@Lazy注释，或者@Lazy 被设置为false，那么该bean 就会急切渴望被加载；除了上面两种作用域，@Lazy 还可以作用在@Autowired和@Inject注释的属性上，在这种情况下，它将为该字段创建一个惰性代理，作为使用ObjectFactory或Provider的默认方法。下面来演示一下： @Lazy @Configuration @ComponentScan(basePackages = &quot;com.spring.configuration.pojo&quot;) public class AppConfigWithLazy { @Bean public MyBean myBean(){ System.out.println(&quot;myBean Initialized&quot;); return new MyBean(); } @Bean public MyBean IfLazyInit(){ System.out.println(&quot;initialized&quot;); return new MyBean(); } } 修改测试类 public class SpringConfigurationApplication { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithLazy.class); // 获取启动过程中的bean 定义的名称 for(String str : context.getBeanDefinitionNames()){ System.out.println(&quot;str = &quot; + str); } } } 输出你会发现没有关于bean的定义信息，但是当把@Lazy 注释拿掉，你会发现输出了关于bean的初始化信息 @DependsOn 注解 指当前bean所依赖的bean。任何指定的bean都能保证在此bean创建之前由IOC容器创建。在bean没有通过属性或构造函数参数显式依赖于另一个bean的情况下很少使用，可能直接使用在任何直接或者间接使用 Component 或者Bean 注解表明的类上。来看一下具体的用法 新建三个Bean，分别是FirstBean、SecondBean、ThirdBean三个普通的bean，新建AppConfigWithDependsOn并配置它们之间的依赖关系 public class FirstBean { @Autowired private SecondBean secondBean; @Autowired private ThirdBean thirdBean; public FirstBean() { System.out.println(&quot;FirstBean Initialized via Constuctor&quot;); } } public class SecondBean { public SecondBean() { System.out.println(&quot;SecondBean Initialized via Constuctor&quot;); } } public class ThirdBean { public ThirdBean() { System.out.println(&quot;ThirdBean Initialized via Constuctor&quot;); } } @Configuration public class AppConfigWithDependsOn { @Bean(&quot;firstBean&quot;) @DependsOn(value = { &quot;secondBean&quot;, &quot;thirdBean&quot; }) public FirstBean firstBean() { return new FirstBean(); } @Bean(&quot;secondBean&quot;) public SecondBean secondBean() { return new SecondBean(); } @Bean(&quot;thirdBean&quot;) public ThirdBean thirdBean() { return new ThirdBean(); } } 使用测试类进行测试，如下 // ------------------------------ 测试 DependsOn ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithDependsOn.class); context.getBean(FirstBean.class); context.close(); 输出 : SecondBean Initialized via Constuctor ThirdBean Initialized via Constuctor FirstBean Initialized via Constuctor 由于firstBean 的创建过程首先需要依赖secondBean 和 thirdBean的创建，所以secondBean 首先被加载其次是thirdBean 最后是firstBean。 如果把@DependsOn 注解加在AppConfigWithDependsOn 类上则它们的初始化顺序就会变为 firstBean、secondBean、thirdBean @Primary 注解 指示当多个候选者有资格自动装配依赖项时，应优先考虑bean。此注解在语义上就等同于在Spring XML中定义的bean 元素的primary属性。注意： 除非使用component-scanning进行组件扫描，否则在类级别上使用@Primary不会有作用。如果@Primary 注解定义在XML中，那么@Primary 的注解元注解就会忽略，相反使用 @Primary 的两种使用方式 与@Bean 一起使用，定义在方法上，方法级别的注解 与@Component 一起使用，定义在类上，类级别的注解 通过一则示例来演示一下： 新建一个AppConfigWithPrimary类，在方法级别上定义@Primary注解 @Configuration public class AppConfigWithPrimary { @Bean public MyBean myBeanOne(){ return new MyBean(); } @Bean @Primary public MyBean myBeanTwo(){ return new MyBean(); } } 上面代码定义了两个bean ，其中myBeanTwo 由@Primary 进行标注，表示它首先会进行注册，使用测试类进行测试 // ------------------------------ 测试 Primary ------------------------------ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithPrimary.class); MyBean bean = context.getBean(MyBean.class); System.out.println(bean); 你可以尝试放开@Primary ，使用测试类测试的话会发现出现报错信息，因为你尝试获取的是MyBean.class,而我们代码中定义了两个MyBean 的类型，所以需要@Primary 注解表明哪一个bean需要优先被获取。 ","link":"https://esinew.github.io/post/wei-shi-me-yao-yong-spring-bean/"}]}